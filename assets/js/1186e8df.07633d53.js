"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2606],{9789(e,s,n){n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Example Programs/Formula Simplification","title":"Formula Simplification","description":"Different applications vary in the requirements for formula simplification.","source":"@site/docs-programming/03 - Example Programs/04 - Formula Simplification.md","sourceDirName":"03 - Example Programs","slug":"/Example Programs/Formula Simplification","permalink":"/z3guide/programming/Example Programs/Formula Simplification","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/z3guide/tree/main/website/docs-programming/03 - Example Programs/04 - Formula Simplification.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Formula Simplification","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"SPACER","permalink":"/z3guide/programming/Example Programs/SPACER"},"next":{"title":"MBQI","permalink":"/z3guide/programming/Example Programs/MBQI"}}');var t=n(4848),a=n(8453);n(6851);const r={title:"Formula Simplification",sidebar_position:4},l=void 0,o={},c=[{value:"Built-in simplification",id:"built-in-simplification",level:2},{value:"Developing simplification using Z3",id:"developing-simplification-using-z3",level:2},{value:"Subterm simplification",id:"subterm-simplification",level:2}];function m(e){const s={annotation:"annotation",code:"code",h2:"h2",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:"Different applications vary in the requirements for formula simplification.\nZ3 exposes a few built-in methods that can be used for simple algebraic simplification.\nThere are no methods based on z3 that ensure that expressions are simplified to a unique canonical form\n(which is a characteristic of simplifying propositional formulas using BDDs), but you can use z3\nto simplify subformulas using different criteria."}),"\n",(0,t.jsx)(s.h2,{id:"built-in-simplification",children:"Built-in simplification"}),"\n",(0,t.jsx)(s.p,{children:"Z3 exposes some built-in methods for formula simplification"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Method from SMTLIB"}),(0,t.jsx)(s.th,{children:"Method from Python"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"simplify"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"simplify(..)"})}),(0,t.jsx)(s.td,{children:"performs rewriting simplification"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"(apply ctx-simplify)"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Tactic('ctx-simplify').apply(..)"})}),(0,t.jsx)(s.td,{children:"maintains Boolean skeleton of formula but removes sub-formulas that are subsumed by context. It uses a syntactic equality check on expressions to determine subsumption."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"(apply ctx-solver-simplify)"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Tactic('ctx-solver-simplify').apply(..)"})}),(0,t.jsx)(s.td,{children:"uses solver calls to determine context subsumption."})]})]})]}),"\n",(0,t.jsx)(s.h2,{id:"developing-simplification-using-z3",children:"Developing simplification using Z3"}),"\n",(0,t.jsx)(s.p,{children:"In the following we outline a procedure for extracting a simplified\nCNF representation of a formula."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"\nfrom z3 import *\n\ndef is_atom(t):\n    if not is_bool(t):\n        return False\n    if not is_app(t):\n        return False\n    k = t.decl().kind()\n    if k == Z3_OP_AND or k == Z3_OP_OR or k == Z3_OP_IMPLIES:\n        return False\n    if k == Z3_OP_EQ and t.arg(0).is_bool():\n        return False\n    if k == Z3_OP_TRUE or k == Z3_OP_FALSE or k == Z3_OP_XOR or k == Z3_OP_NOT:\n        return False\n    return True\n\ndef atoms(fml):\n    visited = set([])\n    atms = set([])\n    def atoms_rec(t, visited, atms):\n        if t in visited:\n            return\n        visited |= { t }\n        if is_atom(t):\n            atms |= { t }\n        for s in t.children():\n            atoms_rec(s, visited, atms)\n    atoms_rec(fml, visited, atms)\n    return atms\n\ndef atom2literal(m, a):\n    if is_true(m.eval(a)):\n        return a\n    return Not(a)\n\n"})}),"\n",(0,t.jsx)(s.p,{children:"Extract subset of atoms used to satisfy the negation\nof a formula."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"snot is a solver for Not(fml)"}),"\n",(0,t.jsx)(s.li,{children:"s    is a solver for fml"}),"\n",(0,t.jsx)(s.li,{children:"m    is a model for Not(fml)"}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["evaluate each atom in ",(0,t.jsx)(s.code,{children:"fml"})," using ",(0,t.jsx)(s.code,{children:"m"})," and create\nliterals corresponding to the sign of the evaluation.\nIf the model evaluates atoms to false, the literal is\nnegated."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"def implicant(atoms, s, snot):\n    m = snot.model()\n    lits = [atom2literal(m, a) for a in atoms]\n    is_sat = s.check(lits)\n    assert is_sat == unsat\n    core = s.unsat_core()\n    return Or([mk_not(c) for c in core])\n\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Extract a CNF representation of ",(0,t.jsx)(s.code,{children:"fml"}),"\nThe procedure uses two solvers\nEnumerate models for ",(0,t.jsx)(s.code,{children:"Not(fml)"}),"\nUse the enumerated model to identify literals\nthat imply ",(0,t.jsx)(s.code,{children:"Not(fml)"}),"\nThe CNF of ",(0,t.jsx)(s.code,{children:"fml"})," is a conjunction of the\nnegation of these literals."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"\ndef to_cnf(fml):\n    atms = atoms(fml)\n    s = Solver()\n    snot = Solver()\n    snot.add(Not(fml))\n    s.add(fml)\n\n    while sat == snot.check():\n        clause = implicant(atms, s, snot)\n        yield clause\n        snot.add(clause)\n\n        \na, b, c, = Bools('a b c')\nfml = Or(And(a, b), And(Not(a), c))\n\nfor clause in to_cnf(fml):\n    print(clause)\n    \n"})}),"\n",(0,t.jsx)(s.h2,{id:"subterm-simplification",children:"Subterm simplification"}),"\n",(0,t.jsxs)(s.p,{children:["The simplification routine exposed by Z3 performs only\nrudimentary algebraic simplifications. It also does not\nuse contextual information into account. In the following\nexample we develop a custom simplifier ",(0,t.jsx)(s.code,{children:"simplify"}),"\nthat uses the current context to find subterms that are\nequal to the term being considered. In the example below,\nthe term ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mn,{children:"4"}),(0,t.jsx)(s.mo,{children:"+"}),(0,t.jsx)(s.mn,{children:"4"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"H"}),(0,t.jsx)(s.mo,{children:"\u2212"}),(0,t.jsx)(s.mn,{children:"1"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"}),(0,t.jsx)(s.mi,{mathvariant:"normal",children:"/"}),(0,t.jsx)(s.mn,{children:"2"}),(0,t.jsx)(s.mi,{mathvariant:"normal",children:"/"}),(0,t.jsx)(s.mn,{children:"2"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"4 + 4((H-1)/2/2)"})]})})}),(0,t.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,t.jsx)(s.span,{className:"mord",children:"4"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(s.span,{className:"mbin",children:"+"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord",children:"4"}),(0,t.jsx)(s.span,{className:"mopen",children:"(("}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.08125em"},children:"H"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(s.span,{className:"mbin",children:"\u2212"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord",children:"1"}),(0,t.jsx)(s.span,{className:"mclose",children:")"}),(0,t.jsx)(s.span,{className:"mord",children:"/2/2"}),(0,t.jsx)(s.span,{className:"mclose",children:")"})]})]})]})," is equal to ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsx)(s.mrow,{children:(0,t.jsx)(s.mi,{children:"H"})}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"H"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.08125em"},children:"H"})]})})]}),"."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"H = Int('H')\ns = Solver()\nt = 4 + 4 * (((H - 1) / 2) / 2)\ns.add(H % 4 == 0)\ns.check()\nm = s.model()\nprint(t, \"--\x3e\", simplify(s, m, t))\n"})}),"\n",(0,t.jsx)(s.p,{children:"To extract set of subterms it is useful to avoid traversing\nthe same term twice."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"\ndef subterms(t):\n    seen = {}\n    def subterms_rec(t):\n        if is_app(t):\n            for ch in t.children():\n                if ch in seen:\n                    continue\n                seen[ch] = True\n                yield ch\n                yield from subterms_rec(ch)\n    return { s for s in subterms_rec(t) }\n"})}),"\n",(0,t.jsx)(s.p,{children:"We can then define the simplification routine:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"def are_equal(s, t1, t2):\n    s.push()\n    s.add(t1 != t2)\n    r = s.check()\n    s.pop()\n    return r == unsat\n\ndef simplify(slv, mdl, t):\n    subs = subterms(t)\n    values = { s : mdl.eval(s) for s in subs }\n    values[t] = mdl.eval(t)\n    def simplify_rec(t):        \n        subs = subterms(t)\n        for s in subs:\n            if s.sort().eq(t.sort()) and values[s].eq(values[t]) and are_equal(slv, s, t):\n                return simplify_rec(s)\n        chs = [simplify_rec(ch) for ch in t.children()]\n        return t.decl()(chs)\n    return simplify_rec(t)\n"})})]})}function d(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}}}]);