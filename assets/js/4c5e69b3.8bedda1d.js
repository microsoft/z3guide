"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7616],{3090(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"fixedpoints/basicdatalog","title":"Basic Datalog","description":"The default fixed-point engine is a bottom-up Datalog engine. It works with finite relations and uses finite table representations as hash tables as the default way to represent finite relations.","source":"@site/docs-smtlib/05 - fixedpoints/02 - basicdatalog.md","sourceDirName":"05 - fixedpoints","slug":"/fixedpoints/basicdatalog","permalink":"/z3guide/docs/fixedpoints/basicdatalog","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/05 - fixedpoints/02 - basicdatalog.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Basic Datalog","sidebar_position":2},"sidebar":"smtlibSidebar","previous":{"title":"Introduction","permalink":"/z3guide/docs/fixedpoints/intro"},"next":{"title":"Generalized PDR with SPACER","permalink":"/z3guide/docs/fixedpoints/engineforpdr"}}');var r=t(4848),a=t(8453),i=t(6851);const l={title:"Basic Datalog",sidebar_position:2},o=void 0,d={},c=[{value:"Relations, rules and queries",id:"relations-rules-and-queries",level:2},{value:"Relations with arguments",id:"relations-with-arguments",level:2}];function u(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"The default fixed-point engine is a bottom-up Datalog engine. It works with finite relations and uses finite table representations as hash tables as the default way to represent finite relations."}),"\n",(0,r.jsx)(n.h2,{id:"relations-rules-and-queries",children:"Relations, rules and queries"}),"\n",(0,r.jsx)(n.p,{children:"The first example illustrates how to declare relations, rules and how to pose queries."}),"\n",(0,r.jsx)(i.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-rel a ())\\n(declare-rel b ())\\n(declare-rel c ())\\n(rule (=> b a))\\n(rule (=> c b))\\n\\n;(set-option :fixedpoint.engine datalog)\\n(query a)\\n\\n(rule c)\\n(query a\\n :print-answer true)","result":{"output":"unsat\\nsat\\ntrue\\n","error":"","status":"z3-ran","hash":"c0814288904cb5e3007a4b368930b11acc03bcf0"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,r.jsx)(n.p,{children:"The example illustrates some of the basic constructs."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:" (declare-rel a ())\n"})}),"\n",(0,r.jsx)(n.p,{children:"declares a 0-ary relation a."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"  (rule (=> b a))\n"})}),"\n",(0,r.jsx)(n.p,{children:"Create the rule that a follows from b. In general you can create a rule with multiple premises and a name using the format"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"   (rule (=> (and b c) a) name)\n"})}),"\n",(0,r.jsx)(n.p,{children:"The name is optional. It is used for tracking the rule in derivation proofs. Continuing with the example, a is false unless b is established."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:" (query a)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Asks if relation ",(0,r.jsx)(n.code,{children:"a"})," can be derived. The rules so far say that a follows if ",(0,r.jsx)(n.code,{children:"b"})," is established and that ",(0,r.jsx)(n.code,{children:"b"})," follows if ",(0,r.jsx)(n.code,{children:"c"})," is established. But nothing establishes ",(0,r.jsx)(n.code,{children:"c"})," and ",(0,r.jsx)(n.code,{children:"b"})," is also not established, so ",(0,r.jsx)(n.code,{children:"a"})," cannot be derived."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:" (rule c)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now it is the case that a can be derived."}),"\n",(0,r.jsx)(n.h2,{id:"relations-with-arguments",children:"Relations with arguments"}),"\n",(0,r.jsx)(n.p,{children:"Relations can take arguments. We illustrate relations with arguments using edges and paths in a graph."}),"\n",(0,r.jsx)(i.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":";(set-option :fixedpoint.engine datalog)\\n(define-sort s () (_ BitVec 3))\\n(declare-rel edge (s s))\\n(declare-rel path (s s))\\n(declare-var a s)\\n(declare-var b s)\\n(declare-var c s)\\n\\n(rule (=> (edge a b) (path a b)))\\n(rule (=> (and (path a b) (path b c)) (path a c)))\\n\\n(rule (edge #b001 #b010))\\n(rule (edge #b001 #b011))\\n(rule (edge #b010 #b100))\\n\\n(declare-rel q1 ())\\n(declare-rel q2 ())\\n(declare-rel q3 (s))\\n(rule (=> (path #b001 #b100) q1))\\n(rule (=> (path #b011 #b100) q2))\\n(rule (=> (path #b001 b) (q3 b)))\\n\\n(query q1)\\n(query q2)\\n(query q3 :print-answer true)","result":{"output":"sat\\nunsat\\nsat\\n(or (= (:var 0) #b010) (= (:var 0) #b100) (= (:var 0) #b011))\\n","error":"","status":"z3-ran","hash":"f9431d85b4bb26034c9c74fe22a637f6350a0712"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,r.jsx)(n.p,{children:"The example uses the declaration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:" (declare-var a s)\n"})}),"\n",(0,r.jsx)(n.p,{children:"to instrument the fixed-point engine that a should be treated as a variable appearing in rules."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);