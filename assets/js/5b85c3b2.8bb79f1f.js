"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6577],{4303:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>f,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"theories/IEEE Floats","title":"IEEE Floats","description":"SMTLIB2 standard IEEE Floating Point Numbers","source":"@site/docs-smtlib/02 - theories/03 - IEEE Floats.md","sourceDirName":"02 - theories","slug":"/theories/IEEE Floats","permalink":"/z3guide/docs/theories/IEEE Floats","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/02 - theories/03 - IEEE Floats.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"IEEE Floats","sidebar_position":3},"sidebar":"smtlibSidebar","previous":{"title":"Bitvectors","permalink":"/z3guide/docs/theories/Bitvectors"},"next":{"title":"Arrays","permalink":"/z3guide/docs/theories/Arrays"}}');var o=s(4848),r=s(8453),i=s(6851);const a={title:"IEEE Floats",sidebar_position:3},l=void 0,d={},c=[];function u(e){const t={a:"a",blockquote:"blockquote",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"SMTLIB2 standard"})," ",(0,o.jsx)(t.a,{href:"https://smt-lib.org/theories-FloatingPoint.shtml",children:"IEEE Floating Point Numbers"})]}),"\n"]}),"\n",(0,o.jsx)(i.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-fun X () (_ FloatingPoint 11 53))\\n\\n(assert (fp.isNormal X))\\n(assert (not (fp.isSubnormal X)))\\n(assert (not (fp.isZero X)))\\n(assert (not (fp.isInfinite X)))\\n(assert (not (fp.isNaN X)))\\n(assert (not (fp.isNegative X)))\\n(assert (fp.isPositive X))\\n\\n(check-sat)\\n(get-model)","result":{"output":"sat\\n(\\n  (define-fun X () (_ FloatingPoint 11 53)\\n    (fp #b0 #b00000000001 #x0000000000000))\\n)\\n","error":"","status":"z3-ran","hash":"a72d8549501daa0494ea42e0cdef7eb57732e638"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,o.jsx)(t.p,{children:"Floating point operations are defined modulo rounding modes.\nMany algebraic properties of bit-vectors, integers and reals don't carry over to floating points.\nFor example, addition is not associative."}),"\n",(0,o.jsx)(i.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const a Float32)\\n(declare-const b Float32)\\n(declare-const c Float32)\\n\\n(assert (not (= (fp.add roundNearestTiesToEven a (fp.add roundNearestTiesToEven b c))\\n\\t        (fp.add roundNearestTiesToEven (fp.add roundNearestTiesToEven a b) c))))\\n(check-sat)\\n(get-model)","result":{"output":"sat\\n(\\n  (define-fun a () Float32\\n    (fp #b0 #xba #b11111111111111111110100))\\n  (define-fun c () Float32\\n    (fp #b0 #x94 #b00000010010000000000000))\\n  (define-fun b () Float32\\n    (fp #b1 #xbb #b00000000000000000000010))\\n)\\n","error":"","status":"z3-ran","hash":"444c10aa6b9177c269cc24ae66146caf1074e26f"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'})]})}function f(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}}}]);