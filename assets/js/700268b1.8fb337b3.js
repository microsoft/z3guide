"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[9993],{9836(e,t,n){n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"strategies/tactics","title":"Tactics","description":"Z3 comes equipped with many built-in tactics. The command (help-tactic) provides a short description of all built-in tactics.","source":"@site/docs-smtlib/03 - strategies/03 - tactics.md","sourceDirName":"03 - strategies","slug":"/strategies/tactics","permalink":"/z3guide/docs/strategies/tactics","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/03 - strategies/03 - tactics.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Tactics","sidebar_position":3},"sidebar":"smtlibSidebar","previous":{"title":"Goals","permalink":"/z3guide/docs/strategies/goals"},"next":{"title":"Probes","permalink":"/z3guide/docs/strategies/probes"}}');var i=n(4848),o=n(8453),l=n(6851);const s={title:"Tactics",sidebar_position:3},r=void 0,u={},d=[];function f(e){const t={code:"code",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Z3 comes equipped with many built-in tactics. The command (help-tactic) provides a short description of all built-in tactics."}),"\n",(0,i.jsx)(l.A,{input:"{\"lang\":\"z3\",\"highlight\":\"clojure\",\"statusCodes\":{\"success\":\"z3-ran\",\"timeout\":\"z3-timed-out\",\"runError\":\"z3-failed\",\"runtimeError\":\"z3-runtime-error\"},\"code\":\"(help-tactic)\",\"result\":{\"output\":\"\\\"combinators:\\n- (and-then <tactic>+) executes the given tactics sequentially.\\n- (or-else <tactic>+) tries the given tactics in sequence until one of them succeeds (i.e., the first that doesn't fail).\\n- (par-or <tactic>+) executes the given tactics in parallel until one of them succeeds (i.e., the first that doesn't fail).\\n- (par-then <tactic1> <tactic2>) executes tactic1 and then tactic2 to every subgoal produced by tactic1. All subgoals are processed in parallel.\\n- (try-for <tactic> <num>) executes the given tactic for at most <num> milliseconds, it fails if the execution takes more than <num> milliseconds.\\n- (if <probe> <tactic> <tactic>) if <probe> evaluates to true, then execute the first tactic. Otherwise execute the second.\\n- (when <probe> <tactic>) shorthand for (if <probe> <tactic> skip).\\n- (fail-if <probe>) fail if <probe> evaluates to true.\\n- (using-params <tactic> <attribute>*) executes the given tactic using the given attributes, where <attribute> ::= <keyword> <value>. ! is a syntax sugar for using-params.\\nbuiltin tactics:\\n- ackermannize_bv A tactic for performing full Ackermannization on bv instances.\\n    div0_ackermann_limit (unsigned int) a bound for number of congruence Ackermann lemmas for div0 modelling (default: 1000)\\n- subpaving tactic for testing subpaving module.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    epsilon (unsigned int) (default: 20) value k s.t. a new lower (upper) bound for x is propagated only new-lower(x) > lower(k) + 1/k * max(min(upper(x) - lower(x), |lower|), 1) (new-upper(x) < upper(x) - 1/k * max(min(upper(x) - lower(x), |lower|), 1)). If k = 0, then this restriction is ignored.\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    max_bound (unsigned int) (default 10) value k s.t. a new upper (lower) bound for x is propagated only if upper(x) > -10^k or lower(x) = -oo (lower(x) < 10^k or upper(x) = oo)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_depth (unsigned int) (default: 128) maximum depth of the subpaving tree.\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_nodes (unsigned int) (default: 8192) maximum number of nodes in the subpaving tree.\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    nth_root_precision (unsigned int) (default 8192) value k s.t. 1/k is the precision for computing the nth root in the subpaving module.\\n    numeral (symbol) (default: mpq) options: mpq, mpf, hwf, mpff, mpfx.\\n    print_nodes (bool) (default: false) display subpaving tree leaves.\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n- horn apply tactic for horn clauses.\\n    bmc.linear_unrolling_depth (unsigned int) Maximal level to explore (default: 4294967295)\\n    ctrl_c (bool) enable interrupts from ctrl-c (default: true)\\n    datalog.all_or_nothing_deltas (bool) compile rules so that it is enough for the delta relation in union and widening operations to determine only whether the updated relation was modified or not (default: false)\\n    datalog.check_relation (symbol) name of default relation to check. operations on the default relation will be verified using SMT solving (default: null)\\n    datalog.compile_with_widening (bool) widening will be used to compile recursive rules (default: false)\\n    datalog.dbg_fpr_nonempty_relation_signature (bool) if true, finite_product_relation will attempt to avoid creating inner relation with empty signature by putting in half of the table columns, if it would have been empty otherwise (default: false)\\n    datalog.default_relation (symbol) default relation implementation: external_relation, pentagon (default: pentagon)\\n    datalog.default_table (symbol) default table implementation: sparse, hashtable, bitvector, interval (default: sparse)\\n    datalog.default_table_checked (bool) if true, the default table will be default_table inside a wrapper that checks that its results are the same as of default_table_checker table (default: false)\\n    datalog.default_table_checker (symbol) see default_table_checked (default: null)\\n    datalog.explanations_on_relation_level (bool) if true, explanations are generated as history of each relation, rather than per fact (generate_explanations must be set to true for this option to have any effect) (default: false)\\n    datalog.generate_explanations (bool) produce explanations for produced facts when using the datalog engine (default: false)\\n    datalog.initial_restart_timeout (unsigned int) length of saturation run before the first restart (in ms), zero means no restarts (default: 0)\\n    datalog.magic_sets_for_queries (bool) magic set transformation will be used for queries (default: false)\\n    datalog.output_profile (bool) determines whether profile information should be output when outputting Datalog rules or instructions (default: false)\\n    datalog.print.tuples (bool) determines whether tuples for output predicates should be output (default: true)\\n    datalog.profile_timeout_milliseconds (unsigned int) instructions and rules that took less than the threshold will not be printed when printed the instruction/rule list (default: 0)\\n    datalog.similarity_compressor (bool) rules that differ only in values of constants will be merged into a single rule (default: true)\\n    datalog.similarity_compressor_threshold (unsigned int) if similarity_compressor is on, this value determines how many similar rules there must be in order for them to be merged (default: 11)\\n    datalog.subsumption (bool) if true, removes/filters predicates with total transitions (default: true)\\n    datalog.timeout (unsigned int) Time limit used for saturation (default: 0)\\n    datalog.unbound_compressor (bool) auxiliary relations will be introduced to avoid unbound variables in rule heads (default: true)\\n    datalog.use_map_names (bool) use names from map files when displaying tuples (default: true)\\n    engine (symbol) Select: auto-config, datalog, bmc, spacer (default: auto-config)\\n    generate_proof_trace (bool) trace for 'sat' answer as proof object (default: false)\\n    print_aig (symbol) Dump clauses in AIG text format (AAG) to the given file name (default: )\\n    print_answer (bool) print answer instance(s) to query (default: false)\\n    print_boogie_certificate (bool) print certificate for reachability or non-reachability using a format understood by Boogie (default: false)\\n    print_certificate (bool) print certificate for reachability or non-reachability (default: false)\\n    print_fixedpoint_extensions (bool) use SMT-LIB2 fixedpoint extensions, instead of pure SMT2, when printing rules (default: true)\\n    print_low_level_smt2 (bool) use (faster) low-level SMT2 printer (the printer is scalable but the result may not be as readable) (default: false)\\n    print_statistics (bool) print statistics (default: false)\\n    print_with_variable_declarations (bool) use variable declarations when displaying rules (instead of attempting to use original names) (default: true)\\n    spacer.arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 2)\\n    spacer.blast_term_ite_inflation (unsigned int) Maximum inflation for non-Boolean ite-terms expansion: 0 (none), k (multiplicative) (default: 3)\\n    spacer.ctp (bool) Enable counterexample-to-pushing (default: true)\\n    spacer.dump_benchmarks (bool) Dump SMT queries as benchmarks (default: false)\\n    spacer.dump_threshold (double) Threshold in seconds on dumping benchmarks (default: 5.0)\\n    spacer.elim_aux (bool) Eliminate auxiliary variables in reachability facts (default: true)\\n    spacer.eq_prop (bool) Enable equality and bound propagation in arithmetic (default: true)\\n    spacer.expand_bnd (bool) Enable expand-bound lemma generalization (default: false)\\n    spacer.gg.concretize (bool) Enable global guidance concretize (default: true)\\n    spacer.gg.conjecture (bool) Enable global guidance conjecture (default: true)\\n    spacer.gg.subsume (bool) Enable global guidance subsume (default: true)\\n    spacer.global (bool) Enable global guidance (default: false)\\n    spacer.gpdr (bool) Use GPDR solving strategy for non-linear CHC (default: false)\\n    spacer.gpdr.bfs (bool) Use BFS exploration strategy for expanding model search (default: true)\\n    spacer.ground_pobs (bool) Ground pobs by using values from a model (default: true)\\n    spacer.iuc (unsigned int) 0 = use old implementation of unsat-core-generation, 1 = use new implementation of IUC generation, 2 = use new implementation of IUC + min-cut optimization (default: 1)\\n    spacer.iuc.arith (unsigned int) 0 = use simple Farkas plugin, 1 = use simple Farkas plugin with constant from other partition (like old unsat-core-generation),2 = use Gaussian elimination optimization (broken), 3 = use additive IUC plugin (default: 1)\\n    spacer.iuc.debug_proof (bool) prints proof used by unsat-core-learner for debugging purposes (debugging) (default: false)\\n    spacer.iuc.old_hyp_reducer (bool) use old hyp reducer instead of new implementation, for debugging only (default: false)\\n    spacer.iuc.print_farkas_stats (bool) prints for each proof how many Farkas lemmas it contains and how many of these participate in the cut (for debugging) (default: false)\\n    spacer.iuc.split_farkas_literals (bool) Split Farkas literals (default: false)\\n    spacer.keep_proxy (bool) keep proxy variables (internal parameter) (default: true)\\n    spacer.logic (symbol) SMT-LIB logic to configure internal SMT solvers (default: )\\n    spacer.max_level (unsigned int) Maximum level to explore (default: 4294967295)\\n    spacer.max_num_contexts (unsigned int) maximal number of contexts to create (default: 500)\\n    spacer.mbqi (bool) Enable mbqi (default: true)\\n    spacer.min_level (unsigned int) Minimal level to explore (default: 0)\\n    spacer.native_mbp (bool) Use native mbp of Z3 (default: true)\\n    spacer.order_children (unsigned int) SPACER: order of enqueuing children in non-linear rules : 0 (original), 1 (reverse), 2 (random) (default: 0)\\n    spacer.p3.share_invariants (bool) Share invariants lemmas (default: false)\\n    spacer.p3.share_lemmas (bool) Share frame lemmas (default: false)\\n    spacer.propagate (bool) Enable propagate/pushing phase (default: true)\\n    spacer.push_pob (bool) push blocked pobs to higher level (default: false)\\n    spacer.push_pob_max_depth (unsigned int) Maximum depth at which push_pob is enabled (default: 4294967295)\\n    spacer.q3 (bool) Allow quantified lemmas in frames (default: true)\\n    spacer.q3.instantiate (bool) Instantiate quantified lemmas (default: true)\\n    spacer.q3.qgen.normalize (bool) normalize cube before quantified generalization (default: true)\\n    spacer.q3.use_qgen (bool) use quantified lemma generalizer (default: false)\\n    spacer.random_seed (unsigned int) Random seed to be used by SMT solver (default: 0)\\n    spacer.reach_dnf (bool) Restrict reachability facts to DNF (default: true)\\n    spacer.reset_pob_queue (bool) SPACER: reset pob obligation queue when entering a new level (default: true)\\n    spacer.restart_initial_threshold (unsigned int) Initial threshold for restarts (default: 10)\\n    spacer.restarts (bool) Enable resetting obligation queue (default: false)\\n    spacer.simplify_lemmas_post (bool) simplify derived lemmas after inductive propagation (default: false)\\n    spacer.simplify_lemmas_pre (bool) simplify derived lemmas before inductive propagation (default: false)\\n    spacer.simplify_pob (bool) simplify pobs by removing redundant constraints (default: false)\\n    spacer.trace_file (symbol) Log file for progress events (default: )\\n    spacer.use_array_eq_generalizer (bool) SPACER: attempt to generalize lemmas with array equalities (default: true)\\n    spacer.use_bg_invs (bool) Enable external background invariants (default: false)\\n    spacer.use_derivations (bool) SPACER: using derivation mechanism to cache intermediate results for non-linear rules (default: true)\\n    spacer.use_euf_gen (bool) Generalize lemmas and pobs using implied equalities (default: false)\\n    spacer.use_inc_clause (bool) Use incremental clause to represent trans (default: true)\\n    spacer.use_inductive_generalizer (bool) generalize lemmas using induction strengthening (default: true)\\n    spacer.use_iuc (bool) Enable Interpolating Unsat Core(IUC) for lemma generalization (default: true)\\n    spacer.use_lemma_as_cti (bool) SPACER: use a lemma instead of a CTI in flexible_trace (default: false)\\n    spacer.use_lim_num_gen (bool) Enable limit numbers generalizer to get smaller numbers (default: false)\\n    spacer.validate_lemmas (bool) Validate each lemma after generalization (default: false)\\n    spacer.weak_abs (bool) Weak abstraction (default: true)\\n    tab.selection (symbol) selection method for tabular strategy: weight (default), first, var-use (default: weight)\\n    timeout (unsigned int) (default: infty) timeout in milliseconds. (default: 4294967295)\\n    validate (bool) validate result (by proof checking or model checking) (default: false)\\n    xform.array_blast (bool) try to eliminate local array terms using Ackermannization -- some array terms may remain (default: false)\\n    xform.array_blast_full (bool) eliminate all local array variables by QE (default: false)\\n    xform.bit_blast (bool) bit-blast bit-vectors (default: false)\\n    xform.coalesce_rules (bool) coalesce rules (default: false)\\n    xform.coi (bool) use cone of influence simplification (default: true)\\n    xform.compress_unbound (bool) compress tails with unbound variables (default: true)\\n    xform.elim_term_ite (bool) Eliminate term-ite expressions (default: false)\\n    xform.elim_term_ite.inflation (unsigned int) Maximum inflation for non-Boolean ite-terms blasting: 0 (none), k (multiplicative) (default: 3)\\n    xform.fix_unbound_vars (bool) fix unbound variables in tail (default: false)\\n    xform.inline_eager (bool) try eager inlining of rules (default: true)\\n    xform.inline_linear (bool) try linear inlining method (default: true)\\n    xform.inline_linear_branch (bool) try linear inlining method with potential expansion (default: false)\\n    xform.instantiate_arrays (bool) Transforms P(a) into P(i, a[i] a) (default: false)\\n    xform.instantiate_arrays.enforce (bool) Transforms P(a) into P(i, a[i]), discards a from predicate (default: false)\\n    xform.instantiate_arrays.nb_quantifier (unsigned int) Gives the number of quantifiers per array (default: 1)\\n    xform.instantiate_arrays.slice_technique (symbol) <no-slicing>=> GetId(i) = i, <smash> => GetId(i) = true (default: no-slicing)\\n    xform.instantiate_quantifiers (bool) instantiate quantified Horn clauses using E-matching heuristic (default: false)\\n    xform.magic (bool) perform symbolic magic set transformation (default: false)\\n    xform.quantify_arrays (bool) create quantified Horn clauses from clauses with arrays (default: false)\\n    xform.scale (bool) add scaling variable to linear real arithmetic clauses (default: false)\\n    xform.slice (bool) simplify clause set using slicing (default: true)\\n    xform.subsumption_checker (bool) Enable subsumption checker (no support for model conversion) (default: true)\\n    xform.tail_simplifier_pve (bool) propagate_variable_equivalences (default: true)\\n    xform.transform_arrays (bool) Rewrites arrays equalities and applies select over store (default: false)\\n    xform.unfold_rules (unsigned int) unfold rules statically using iterative squaring (default: 0)\\n- horn-simplify simplify horn clauses.\\n    bmc.linear_unrolling_depth (unsigned int) Maximal level to explore (default: 4294967295)\\n    ctrl_c (bool) enable interrupts from ctrl-c (default: true)\\n    datalog.all_or_nothing_deltas (bool) compile rules so that it is enough for the delta relation in union and widening operations to determine only whether the updated relation was modified or not (default: false)\\n    datalog.check_relation (symbol) name of default relation to check. operations on the default relation will be verified using SMT solving (default: null)\\n    datalog.compile_with_widening (bool) widening will be used to compile recursive rules (default: false)\\n    datalog.dbg_fpr_nonempty_relation_signature (bool) if true, finite_product_relation will attempt to avoid creating inner relation with empty signature by putting in half of the table columns, if it would have been empty otherwise (default: false)\\n    datalog.default_relation (symbol) default relation implementation: external_relation, pentagon (default: pentagon)\\n    datalog.default_table (symbol) default table implementation: sparse, hashtable, bitvector, interval (default: sparse)\\n    datalog.default_table_checked (bool) if true, the default table will be default_table inside a wrapper that checks that its results are the same as of default_table_checker table (default: false)\\n    datalog.default_table_checker (symbol) see default_table_checked (default: null)\\n    datalog.explanations_on_relation_level (bool) if true, explanations are generated as history of each relation, rather than per fact (generate_explanations must be set to true for this option to have any effect) (default: false)\\n    datalog.generate_explanations (bool) produce explanations for produced facts when using the datalog engine (default: false)\\n    datalog.initial_restart_timeout (unsigned int) length of saturation run before the first restart (in ms), zero means no restarts (default: 0)\\n    datalog.magic_sets_for_queries (bool) magic set transformation will be used for queries (default: false)\\n    datalog.output_profile (bool) determines whether profile information should be output when outputting Datalog rules or instructions (default: false)\\n    datalog.print.tuples (bool) determines whether tuples for output predicates should be output (default: true)\\n    datalog.profile_timeout_milliseconds (unsigned int) instructions and rules that took less than the threshold will not be printed when printed the instruction/rule list (default: 0)\\n    datalog.similarity_compressor (bool) rules that differ only in values of constants will be merged into a single rule (default: true)\\n    datalog.similarity_compressor_threshold (unsigned int) if similarity_compressor is on, this value determines how many similar rules there must be in order for them to be merged (default: 11)\\n    datalog.subsumption (bool) if true, removes/filters predicates with total transitions (default: true)\\n    datalog.timeout (unsigned int) Time limit used for saturation (default: 0)\\n    datalog.unbound_compressor (bool) auxiliary relations will be introduced to avoid unbound variables in rule heads (default: true)\\n    datalog.use_map_names (bool) use names from map files when displaying tuples (default: true)\\n    engine (symbol) Select: auto-config, datalog, bmc, spacer (default: auto-config)\\n    generate_proof_trace (bool) trace for 'sat' answer as proof object (default: false)\\n    print_aig (symbol) Dump clauses in AIG text format (AAG) to the given file name (default: )\\n    print_answer (bool) print answer instance(s) to query (default: false)\\n    print_boogie_certificate (bool) print certificate for reachability or non-reachability using a format understood by Boogie (default: false)\\n    print_certificate (bool) print certificate for reachability or non-reachability (default: false)\\n    print_fixedpoint_extensions (bool) use SMT-LIB2 fixedpoint extensions, instead of pure SMT2, when printing rules (default: true)\\n    print_low_level_smt2 (bool) use (faster) low-level SMT2 printer (the printer is scalable but the result may not be as readable) (default: false)\\n    print_statistics (bool) print statistics (default: false)\\n    print_with_variable_declarations (bool) use variable declarations when displaying rules (instead of attempting to use original names) (default: true)\\n    spacer.arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 2)\\n    spacer.blast_term_ite_inflation (unsigned int) Maximum inflation for non-Boolean ite-terms expansion: 0 (none), k (multiplicative) (default: 3)\\n    spacer.ctp (bool) Enable counterexample-to-pushing (default: true)\\n    spacer.dump_benchmarks (bool) Dump SMT queries as benchmarks (default: false)\\n    spacer.dump_threshold (double) Threshold in seconds on dumping benchmarks (default: 5.0)\\n    spacer.elim_aux (bool) Eliminate auxiliary variables in reachability facts (default: true)\\n    spacer.eq_prop (bool) Enable equality and bound propagation in arithmetic (default: true)\\n    spacer.expand_bnd (bool) Enable expand-bound lemma generalization (default: false)\\n    spacer.gg.concretize (bool) Enable global guidance concretize (default: true)\\n    spacer.gg.conjecture (bool) Enable global guidance conjecture (default: true)\\n    spacer.gg.subsume (bool) Enable global guidance subsume (default: true)\\n    spacer.global (bool) Enable global guidance (default: false)\\n    spacer.gpdr (bool) Use GPDR solving strategy for non-linear CHC (default: false)\\n    spacer.gpdr.bfs (bool) Use BFS exploration strategy for expanding model search (default: true)\\n    spacer.ground_pobs (bool) Ground pobs by using values from a model (default: true)\\n    spacer.iuc (unsigned int) 0 = use old implementation of unsat-core-generation, 1 = use new implementation of IUC generation, 2 = use new implementation of IUC + min-cut optimization (default: 1)\\n    spacer.iuc.arith (unsigned int) 0 = use simple Farkas plugin, 1 = use simple Farkas plugin with constant from other partition (like old unsat-core-generation),2 = use Gaussian elimination optimization (broken), 3 = use additive IUC plugin (default: 1)\\n    spacer.iuc.debug_proof (bool) prints proof used by unsat-core-learner for debugging purposes (debugging) (default: false)\\n    spacer.iuc.old_hyp_reducer (bool) use old hyp reducer instead of new implementation, for debugging only (default: false)\\n    spacer.iuc.print_farkas_stats (bool) prints for each proof how many Farkas lemmas it contains and how many of these participate in the cut (for debugging) (default: false)\\n    spacer.iuc.split_farkas_literals (bool) Split Farkas literals (default: false)\\n    spacer.keep_proxy (bool) keep proxy variables (internal parameter) (default: true)\\n    spacer.logic (symbol) SMT-LIB logic to configure internal SMT solvers (default: )\\n    spacer.max_level (unsigned int) Maximum level to explore (default: 4294967295)\\n    spacer.max_num_contexts (unsigned int) maximal number of contexts to create (default: 500)\\n    spacer.mbqi (bool) Enable mbqi (default: true)\\n    spacer.min_level (unsigned int) Minimal level to explore (default: 0)\\n    spacer.native_mbp (bool) Use native mbp of Z3 (default: true)\\n    spacer.order_children (unsigned int) SPACER: order of enqueuing children in non-linear rules : 0 (original), 1 (reverse), 2 (random) (default: 0)\\n    spacer.p3.share_invariants (bool) Share invariants lemmas (default: false)\\n    spacer.p3.share_lemmas (bool) Share frame lemmas (default: false)\\n    spacer.propagate (bool) Enable propagate/pushing phase (default: true)\\n    spacer.push_pob (bool) push blocked pobs to higher level (default: false)\\n    spacer.push_pob_max_depth (unsigned int) Maximum depth at which push_pob is enabled (default: 4294967295)\\n    spacer.q3 (bool) Allow quantified lemmas in frames (default: true)\\n    spacer.q3.instantiate (bool) Instantiate quantified lemmas (default: true)\\n    spacer.q3.qgen.normalize (bool) normalize cube before quantified generalization (default: true)\\n    spacer.q3.use_qgen (bool) use quantified lemma generalizer (default: false)\\n    spacer.random_seed (unsigned int) Random seed to be used by SMT solver (default: 0)\\n    spacer.reach_dnf (bool) Restrict reachability facts to DNF (default: true)\\n    spacer.reset_pob_queue (bool) SPACER: reset pob obligation queue when entering a new level (default: true)\\n    spacer.restart_initial_threshold (unsigned int) Initial threshold for restarts (default: 10)\\n    spacer.restarts (bool) Enable resetting obligation queue (default: false)\\n    spacer.simplify_lemmas_post (bool) simplify derived lemmas after inductive propagation (default: false)\\n    spacer.simplify_lemmas_pre (bool) simplify derived lemmas before inductive propagation (default: false)\\n    spacer.simplify_pob (bool) simplify pobs by removing redundant constraints (default: false)\\n    spacer.trace_file (symbol) Log file for progress events (default: )\\n    spacer.use_array_eq_generalizer (bool) SPACER: attempt to generalize lemmas with array equalities (default: true)\\n    spacer.use_bg_invs (bool) Enable external background invariants (default: false)\\n    spacer.use_derivations (bool) SPACER: using derivation mechanism to cache intermediate results for non-linear rules (default: true)\\n    spacer.use_euf_gen (bool) Generalize lemmas and pobs using implied equalities (default: false)\\n    spacer.use_inc_clause (bool) Use incremental clause to represent trans (default: true)\\n    spacer.use_inductive_generalizer (bool) generalize lemmas using induction strengthening (default: true)\\n    spacer.use_iuc (bool) Enable Interpolating Unsat Core(IUC) for lemma generalization (default: true)\\n    spacer.use_lemma_as_cti (bool) SPACER: use a lemma instead of a CTI in flexible_trace (default: false)\\n    spacer.use_lim_num_gen (bool) Enable limit numbers generalizer to get smaller numbers (default: false)\\n    spacer.validate_lemmas (bool) Validate each lemma after generalization (default: false)\\n    spacer.weak_abs (bool) Weak abstraction (default: true)\\n    tab.selection (symbol) selection method for tabular strategy: weight (default), first, var-use (default: weight)\\n    timeout (unsigned int) (default: infty) timeout in milliseconds. (default: 4294967295)\\n    validate (bool) validate result (by proof checking or model checking) (default: false)\\n    xform.array_blast (bool) try to eliminate local array terms using Ackermannization -- some array terms may remain (default: false)\\n    xform.array_blast_full (bool) eliminate all local array variables by QE (default: false)\\n    xform.bit_blast (bool) bit-blast bit-vectors (default: false)\\n    xform.coalesce_rules (bool) coalesce rules (default: false)\\n    xform.coi (bool) use cone of influence simplification (default: true)\\n    xform.compress_unbound (bool) compress tails with unbound variables (default: true)\\n    xform.elim_term_ite (bool) Eliminate term-ite expressions (default: false)\\n    xform.elim_term_ite.inflation (unsigned int) Maximum inflation for non-Boolean ite-terms blasting: 0 (none), k (multiplicative) (default: 3)\\n    xform.fix_unbound_vars (bool) fix unbound variables in tail (default: false)\\n    xform.inline_eager (bool) try eager inlining of rules (default: true)\\n    xform.inline_linear (bool) try linear inlining method (default: true)\\n    xform.inline_linear_branch (bool) try linear inlining method with potential expansion (default: false)\\n    xform.instantiate_arrays (bool) Transforms P(a) into P(i, a[i] a) (default: false)\\n    xform.instantiate_arrays.enforce (bool) Transforms P(a) into P(i, a[i]), discards a from predicate (default: false)\\n    xform.instantiate_arrays.nb_quantifier (unsigned int) Gives the number of quantifiers per array (default: 1)\\n    xform.instantiate_arrays.slice_technique (symbol) <no-slicing>=> GetId(i) = i, <smash> => GetId(i) = true (default: no-slicing)\\n    xform.instantiate_quantifiers (bool) instantiate quantified Horn clauses using E-matching heuristic (default: false)\\n    xform.magic (bool) perform symbolic magic set transformation (default: false)\\n    xform.quantify_arrays (bool) create quantified Horn clauses from clauses with arrays (default: false)\\n    xform.scale (bool) add scaling variable to linear real arithmetic clauses (default: false)\\n    xform.slice (bool) simplify clause set using slicing (default: true)\\n    xform.subsumption_checker (bool) Enable subsumption checker (no support for model conversion) (default: true)\\n    xform.tail_simplifier_pve (bool) propagate_variable_equivalences (default: true)\\n    xform.transform_arrays (bool) Rewrites arrays equalities and applies select over store (default: false)\\n    xform.unfold_rules (unsigned int) unfold rules statically using iterative squaring (default: 0)\\n- nlsat (try to) solve goal using a nonlinear arithmetic solver.\\n    cell_sample (bool) cell sample projection (default: true)\\n    check_lemmas (bool) check lemmas on the fly using an independent nlsat solver (default: false)\\n    factor (bool) (default: true) factor polynomials.\\n    factor_max_prime (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step (default: 31)\\n    factor_num_primes (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifting and searching (default: 1)\\n    factor_search_size (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space (default: 5000)\\n    inline_vars (bool) inline variables that can be isolated from equations (not supported in incremental mode) (default: false)\\n    lazy (unsigned int) how lazy the solver is. (default: 0)\\n    log_lemmas (bool) display lemmas as self-contained SMT formulas (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts. (default: 4294967295)\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    max_prime (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step.\\n    max_search_size (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space.\\n    min_mag (unsigned int) Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16 (default: 16)\\n    minimize_conflicts (bool) minimize conflicts (default: false)\\n    num_primes (unsigned int) (default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching.\\n    randomize (bool) randomize selection of a witness in nlsat. (default: true)\\n    reorder (bool) reorder variables. (default: true)\\n    seed (unsigned int) random seed. (default: 0)\\n    shuffle_vars (bool) use a random variable order. (default: false)\\n    simple_check (bool) precheck polynomials using variables sign (default: false)\\n    simplify_conflicts (bool) simplify conflicts using equalities before resolving them in nlsat solver. (default: true)\\n    variable_ordering_strategy (unsigned int) Variable Ordering Strategy, 0 for none, 1 for BROWN, 2 for TRIANGULAR, 3 for ONLYPOLY (default: 0)\\n    zero_accuracy (unsigned int) one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k) (default: 0)\\n- qfnra-nlsat builtin strategy for solving QF_NRA problems using only nlsat.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    cell_sample (bool) cell sample projection (default: true)\\n    check_lemmas (bool) check lemmas on the fly using an independent nlsat solver (default: false)\\n    common_patterns (bool) minimize the number of auxiliary variables during CNF encoding by identifying commonly used patterns (default: true)\\n    complete (bool) add constraints to make sure that any interpretation of a underspecified arithmetic operators is a function. The result will include additional uninterpreted functions/constants: /0, div0, mod0, 0^0, neg-root (default: true)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    distributivity (bool) minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas (default: true)\\n    distributivity_blowup (unsigned int) maximum overhead for applying distributivity during CNF encoding (default: 32)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_inverses (bool) eliminate inverse trigonometric functions (asin, acos, atan). (default: true)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_root_objects (bool) eliminate root objects. (default: true)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    factor (bool) (default: true) factor polynomials.\\n    factor_max_prime (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step (default: 31)\\n    factor_num_primes (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifting and searching (default: 1)\\n    factor_search_size (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space (default: 5000)\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    inline_vars (bool) inline variables that can be isolated from equations (not supported in incremental mode) (default: false)\\n    ite_chaing (bool) minimize the number of auxiliary variables during CNF encoding by identifying if-then-else chains (default: true)\\n    ite_extra (bool) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    lazy (unsigned int) how lazy the solver is. (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    log_lemmas (bool) display lemmas as self-contained SMT formulas (default: false)\\n    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.\\n    max_conflicts (unsigned int) maximum number of conflicts. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_prime (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step.\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_search_size (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space.\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    min_mag (unsigned int) Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16 (default: 16)\\n    minimize_conflicts (bool) minimize conflicts (default: false)\\n    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    num_primes (unsigned int) (default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching.\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    randomize (bool) randomize selection of a witness in nlsat. (default: true)\\n    reorder (bool) reorder variables. (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    seed (unsigned int) random seed. (default: 0)\\n    shuffle_vars (bool) use a random variable order. (default: false)\\n    simple_check (bool) precheck polynomials using variables sign (default: false)\\n    simplify_conflicts (bool) simplify conflicts using equalities before resolving them in nlsat solver. (default: true)\\n    sk_hack (bool) hack for VCC (default: false)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    split_factors (bool) apply simplifications such as (= (* p1 p2) 0) --\x3e (or (= p1 0) (= p2 0)). (default: true)\\n    theory_solver (bool) theory solvers. (default: true)\\n    variable_ordering_strategy (unsigned int) Variable Ordering Strategy, 0 for none, 1 for BROWN, 2 for TRIANGULAR, 3 for ONLYPOLY (default: 0)\\n    zero_accuracy (unsigned int) one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k) (default: 0)\\n- qe-light apply light-weight quantifier elimination.\\n- nlqsat apply a NL-QSAT solver.\\n- qe apply quantifier elimination.\\n    eliminate_variables_as_block (bool) (default: true) eliminate variables as a block (true) or one at a time (false)\\n    qe_nonlinear (bool) (default: false) enable virtual term substitution.\\n- qsat apply a QSAT solver.\\n- qe2 apply a QSAT based quantifier elimination.\\n- qe_rec apply a QSAT based quantifier elimination recursively.\\n- psat (try to) solve goal using a parallel SAT solver.\\n    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)\\n    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)\\n    anf (bool) enable ANF based simplification in-processing (default: false)\\n    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)\\n    anf.exlin (bool) enable extended linear simplification (default: false)\\n    asymm_branch (bool) asymmetric branching (default: true)\\n    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)\\n    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)\\n    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)\\n    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)\\n    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)\\n    ate (bool) asymmetric tautology elimination (default: true)\\n    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)\\n    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)\\n    bca (bool) blocked clause addition - add blocked binary clauses (default: false)\\n    bce (bool) eliminate blocked clauses (default: false)\\n    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)\\n    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)\\n    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)\\n    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)\\n    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)\\n    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)\\n    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)\\n    cardinality.solver (bool) use cardinality solver (default: true)\\n    cce (bool) eliminate covered clauses (default: false)\\n    core.minimize (bool) minimize computed core (default: false)\\n    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)\\n    cut (bool) enable AIG based simplification in-processing (default: false)\\n    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)\\n    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)\\n    cut.dont_cares (bool) integrate dont cares with cuts (default: true)\\n    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)\\n    cut.lut (bool) extract luts from clauses for cut simplification (default: false)\\n    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)\\n    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)\\n    cut.xor (bool) extract xors from clauses for cut simplification (default: false)\\n    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)\\n    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)\\n    ddfw.restart_base (unsigned int) number of flips used a starting point for hesitant restart backoff (default: 100000)\\n    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)\\n    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)\\n    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)\\n    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)\\n    drat.activity (bool) dump variable activities (default: false)\\n    drat.binary (bool) use Binary DRAT output format (default: false)\\n    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)\\n    drat.check_unsat (bool) build up internal proof and check (default: false)\\n    drat.disable (bool) override anything that enables DRAT (default: false)\\n    drat.file (symbol) file to dump DRAT proofs (default: )\\n    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)\\n    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)\\n    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)\\n    euf (bool) enable euf solver (this feature is preliminary and not ready for general consumption) (default: false)\\n    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)\\n    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)\\n    gc.burst (bool) perform eager garbage collection during initialization (default: false)\\n    gc.defrag (bool) defragment clauses when garbage collecting (default: true)\\n    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)\\n    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)\\n    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)\\n    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)\\n    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)\\n    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )\\n    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas\\n    learned (bool) (default: false) collect also learned clauses.\\n    local_search (bool) use local search instead of CDCL (default: false)\\n    local_search_dbg_flips (bool) write debug information for number of flips (default: false)\\n    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)\\n    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)\\n    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)\\n    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)\\n    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)\\n    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)\\n    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)\\n    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)\\n    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)\\n    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)\\n    lookahead.double (bool) enable double lookahead (default: true)\\n    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)\\n    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)\\n    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)\\n    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)\\n    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)\\n    lookahead_simplify (bool) use lookahead solver during simplification (default: false)\\n    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)\\n    max_conflicts (unsigned int) maximum number of conflicts (default: 4294967295)\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    minimize_lemmas (bool) minimize learned clauses (default: true)\\n    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)\\n    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)\\n    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)\\n    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)\\n    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)\\n    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching, local_search (default: caching)\\n    phase.sticky (bool) use sticky phase caching (default: true)\\n    prob_search (bool) use probsat local search instead of CDCL (default: false)\\n    probing (bool) apply failed literal detection during simplification (default: true)\\n    probing_binary (bool) probe binary clauses (default: true)\\n    probing_cache (bool) add binary literals as lemmas (default: true)\\n    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)\\n    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)\\n    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)\\n    random_freq (double) frequency of random case splits (default: 0.01)\\n    random_seed (unsigned int) random seed (default: 0)\\n    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)\\n    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)\\n    reorder.itau (double) inverse temperature for softmax (default: 4.0)\\n    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)\\n    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)\\n    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)\\n    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)\\n    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)\\n    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)\\n    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)\\n    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)\\n    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)\\n    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)\\n    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)\\n    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)\\n    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)\\n    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)\\n    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)\\n    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)\\n    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)\\n    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)\\n    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)\\n    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)\\n    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)\\n    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)\\n    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)\\n    smt (bool) use the SAT solver based incremental SMT core (default: false)\\n    smt.proof.check (bool) check proofs on the fly during SMT search (default: false)\\n    subsumption (bool) eliminate subsumed clauses (default: true)\\n    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)\\n    threads (unsigned int) number of parallel threads to use (default: 1)\\n    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)\\n- sat (try to) solve goal using a SAT solver.\\n    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)\\n    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)\\n    anf (bool) enable ANF based simplification in-processing (default: false)\\n    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)\\n    anf.exlin (bool) enable extended linear simplification (default: false)\\n    asymm_branch (bool) asymmetric branching (default: true)\\n    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)\\n    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)\\n    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)\\n    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)\\n    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)\\n    ate (bool) asymmetric tautology elimination (default: true)\\n    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)\\n    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)\\n    bca (bool) blocked clause addition - add blocked binary clauses (default: false)\\n    bce (bool) eliminate blocked clauses (default: false)\\n    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)\\n    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)\\n    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)\\n    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)\\n    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)\\n    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)\\n    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)\\n    cardinality.solver (bool) use cardinality solver (default: true)\\n    cce (bool) eliminate covered clauses (default: false)\\n    core.minimize (bool) minimize computed core (default: false)\\n    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)\\n    cut (bool) enable AIG based simplification in-processing (default: false)\\n    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)\\n    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)\\n    cut.dont_cares (bool) integrate dont cares with cuts (default: true)\\n    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)\\n    cut.lut (bool) extract luts from clauses for cut simplification (default: false)\\n    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)\\n    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)\\n    cut.xor (bool) extract xors from clauses for cut simplification (default: false)\\n    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)\\n    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)\\n    ddfw.restart_base (unsigned int) number of flips used a starting point for hesitant restart backoff (default: 100000)\\n    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)\\n    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)\\n    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)\\n    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)\\n    drat.activity (bool) dump variable activities (default: false)\\n    drat.binary (bool) use Binary DRAT output format (default: false)\\n    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)\\n    drat.check_unsat (bool) build up internal proof and check (default: false)\\n    drat.disable (bool) override anything that enables DRAT (default: false)\\n    drat.file (symbol) file to dump DRAT proofs (default: )\\n    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)\\n    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)\\n    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)\\n    euf (bool) enable euf solver (this feature is preliminary and not ready for general consumption) (default: false)\\n    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)\\n    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)\\n    gc.burst (bool) perform eager garbage collection during initialization (default: false)\\n    gc.defrag (bool) defragment clauses when garbage collecting (default: true)\\n    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)\\n    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)\\n    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)\\n    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)\\n    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)\\n    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )\\n    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas\\n    learned (bool) (default: false) collect also learned clauses.\\n    local_search (bool) use local search instead of CDCL (default: false)\\n    local_search_dbg_flips (bool) write debug information for number of flips (default: false)\\n    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)\\n    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)\\n    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)\\n    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)\\n    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)\\n    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)\\n    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)\\n    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)\\n    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)\\n    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)\\n    lookahead.double (bool) enable double lookahead (default: true)\\n    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)\\n    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)\\n    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)\\n    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)\\n    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)\\n    lookahead_simplify (bool) use lookahead solver during simplification (default: false)\\n    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)\\n    max_conflicts (unsigned int) maximum number of conflicts (default: 4294967295)\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    minimize_lemmas (bool) minimize learned clauses (default: true)\\n    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)\\n    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)\\n    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)\\n    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)\\n    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)\\n    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching, local_search (default: caching)\\n    phase.sticky (bool) use sticky phase caching (default: true)\\n    prob_search (bool) use probsat local search instead of CDCL (default: false)\\n    probing (bool) apply failed literal detection during simplification (default: true)\\n    probing_binary (bool) probe binary clauses (default: true)\\n    probing_cache (bool) add binary literals as lemmas (default: true)\\n    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)\\n    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)\\n    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)\\n    random_freq (double) frequency of random case splits (default: 0.01)\\n    random_seed (unsigned int) random seed (default: 0)\\n    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)\\n    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)\\n    reorder.itau (double) inverse temperature for softmax (default: 4.0)\\n    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)\\n    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)\\n    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)\\n    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)\\n    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)\\n    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)\\n    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)\\n    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)\\n    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)\\n    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)\\n    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)\\n    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)\\n    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)\\n    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)\\n    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)\\n    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)\\n    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)\\n    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)\\n    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)\\n    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)\\n    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)\\n    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)\\n    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)\\n    smt (bool) use the SAT solver based incremental SMT core (default: false)\\n    smt.proof.check (bool) check proofs on the fly during SMT search (default: false)\\n    subsumption (bool) eliminate subsumed clauses (default: true)\\n    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)\\n    threads (unsigned int) number of parallel threads to use (default: 1)\\n    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)\\n- sat-preprocess Apply SAT solver preprocessing procedures (bounded resolution, Boolean constant propagation, 2-SAT, subsumption, subsumption resolution).\\n    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)\\n    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)\\n    anf (bool) enable ANF based simplification in-processing (default: false)\\n    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)\\n    anf.exlin (bool) enable extended linear simplification (default: false)\\n    asymm_branch (bool) asymmetric branching (default: true)\\n    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)\\n    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)\\n    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)\\n    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)\\n    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)\\n    ate (bool) asymmetric tautology elimination (default: true)\\n    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)\\n    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)\\n    bca (bool) blocked clause addition - add blocked binary clauses (default: false)\\n    bce (bool) eliminate blocked clauses (default: false)\\n    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)\\n    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)\\n    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)\\n    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)\\n    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)\\n    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)\\n    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)\\n    cardinality.solver (bool) use cardinality solver (default: true)\\n    cce (bool) eliminate covered clauses (default: false)\\n    core.minimize (bool) minimize computed core (default: false)\\n    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)\\n    cut (bool) enable AIG based simplification in-processing (default: false)\\n    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)\\n    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)\\n    cut.dont_cares (bool) integrate dont cares with cuts (default: true)\\n    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)\\n    cut.lut (bool) extract luts from clauses for cut simplification (default: false)\\n    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)\\n    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)\\n    cut.xor (bool) extract xors from clauses for cut simplification (default: false)\\n    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)\\n    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)\\n    ddfw.restart_base (unsigned int) number of flips used a starting point for hesitant restart backoff (default: 100000)\\n    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)\\n    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)\\n    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)\\n    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)\\n    drat.activity (bool) dump variable activities (default: false)\\n    drat.binary (bool) use Binary DRAT output format (default: false)\\n    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)\\n    drat.check_unsat (bool) build up internal proof and check (default: false)\\n    drat.disable (bool) override anything that enables DRAT (default: false)\\n    drat.file (symbol) file to dump DRAT proofs (default: )\\n    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)\\n    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)\\n    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)\\n    euf (bool) enable euf solver (this feature is preliminary and not ready for general consumption) (default: false)\\n    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)\\n    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)\\n    gc.burst (bool) perform eager garbage collection during initialization (default: false)\\n    gc.defrag (bool) defragment clauses when garbage collecting (default: true)\\n    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)\\n    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)\\n    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)\\n    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)\\n    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)\\n    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )\\n    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas\\n    learned (bool) (default: false) collect also learned clauses.\\n    local_search (bool) use local search instead of CDCL (default: false)\\n    local_search_dbg_flips (bool) write debug information for number of flips (default: false)\\n    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)\\n    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)\\n    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)\\n    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)\\n    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)\\n    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)\\n    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)\\n    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)\\n    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)\\n    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)\\n    lookahead.double (bool) enable double lookahead (default: true)\\n    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)\\n    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)\\n    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)\\n    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)\\n    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)\\n    lookahead_simplify (bool) use lookahead solver during simplification (default: false)\\n    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)\\n    max_conflicts (unsigned int) maximum number of conflicts (default: 4294967295)\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    minimize_lemmas (bool) minimize learned clauses (default: true)\\n    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)\\n    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)\\n    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)\\n    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)\\n    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)\\n    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching, local_search (default: caching)\\n    phase.sticky (bool) use sticky phase caching (default: true)\\n    prob_search (bool) use probsat local search instead of CDCL (default: false)\\n    probing (bool) apply failed literal detection during simplification (default: true)\\n    probing_binary (bool) probe binary clauses (default: true)\\n    probing_cache (bool) add binary literals as lemmas (default: true)\\n    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)\\n    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)\\n    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)\\n    random_freq (double) frequency of random case splits (default: 0.01)\\n    random_seed (unsigned int) random seed (default: 0)\\n    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)\\n    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)\\n    reorder.itau (double) inverse temperature for softmax (default: 4.0)\\n    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)\\n    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)\\n    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)\\n    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)\\n    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)\\n    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)\\n    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)\\n    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)\\n    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)\\n    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)\\n    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)\\n    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)\\n    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)\\n    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)\\n    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)\\n    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)\\n    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)\\n    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)\\n    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)\\n    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)\\n    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)\\n    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)\\n    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)\\n    smt (bool) use the SAT solver based incremental SMT core (default: false)\\n    smt.proof.check (bool) check proofs on the fly during SMT search (default: false)\\n    subsumption (bool) eliminate subsumed clauses (default: true)\\n    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)\\n    threads (unsigned int) number of parallel threads to use (default: 1)\\n    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)\\n- ctx-solver-simplify apply solver-based contextual simplification rules.\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n- psmt builtin strategy for SMT tactic in parallel.\\n- unit-subsume-simplify unit subsumption simplification.\\n- aig simplify Boolean structure using AIGs.\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n- add-bounds add bounds to unbounded variables (under approximation).\\n    add_bound_lower (rational) (default: -2) lower bound to be added to unbounded variables.\\n    add_bound_upper (rational) (default: 2) upper bound to be added to unbounded variables.\\n- card2bv convert pseudo-boolean constraints to bit-vectors.\\n    cardinality.encoding (symbol) encoding used for cardinality constraints: grouped, bimander, ordered, unate, circuit (default: none)\\n    keep_cardinality_constraints (bool) retain cardinality constraints for solver (default: true)\\n    pb.solver (symbol) encoding used for Pseudo-Boolean constraints: totalizer, sorting, binary_merge, bv, solver. PB constraints are retained if set to 'solver' (default: solver)\\n- degree-shift try to reduce degree of polynomials (remark: :mul2power simplification is automatically applied).\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n- diff-neq specialized solver for integer arithmetic problems that contain only atoms of the form (<= k x) (<= x k) and (not (= (- x y) k)), where x and y are constants and k is a numeral, and all constants are bounded.\\n    diff_neq_max_k (unsigned int) maximum variable upper bound for diff neq solver. (default: 1024)\\n- eq2bv convert integer variables used as finite domain elements to bit-vectors.\\n- factor polynomial factorization.\\n    max_prime (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step.\\n    max_search_size (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space.\\n    num_primes (unsigned int) (default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching.\\n    split_factors (bool) apply simplifications such as (= (* p1 p2) 0) --\x3e (or (= p1 0) (= p2 0)). (default: true)\\n- fix-dl-var if goal is in the difference logic fragment, then fix the variable with the most number of occurrences at 0.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n- fm eliminate variables using fourier-motzkin elimination.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    fm_cutoff1 (unsigned int) first cutoff for FM based on maximum number of lower/upper occurrences. (default: 8)\\n    fm_cutoff2 (unsigned int) second cutoff for FM based on num_lower * num_upper occurrences. (default: 256)\\n    fm_extra (unsigned int) max. increase on the number of inequalities for each FM variable elimination step. (default: 0)\\n    fm_limit (unsigned int) maximum number of constraints, monomials, clauses visited during FM. (default: 5000000)\\n    fm_occ (bool) consider inequalities occurring in clauses for FM. (default: false)\\n    fm_real_only (bool) consider only real variables for fourier-motzkin elimination. (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    produce_models (bool) model generation. (default: false)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n- lia2card introduce cardinality constraints from 0-1 integer.\\n    compile_equality (bool) (default:false) compile equalities into pseudo-Boolean equality\\n- lia2pb convert bounded integer variables into a sequence of 0-1 variables.\\n    lia2pb_max_bits (unsigned int) (default: 32) maximum number of bits to be used (per variable) in lia2pb.\\n    lia2pb_partial (bool) (default: false) partial lia2pb conversion.\\n    lia2pb_total_bits (unsigned int) (default: 2048) total number of bits to be used (per problem) in lia2pb.\\n- nla2bv convert a nonlinear arithmetic problem into a bit-vector problem, in most cases the resultant goal is an under approximation and is useul for finding models.\\n    nla2bv_bv_size (unsigned int) default bit-vector size used by nla2bv tactic. (default: 4)\\n    nla2bv_divisor (unsigned int) nla2bv tactic parameter. (default: 2)\\n    nla2bv_max_bv_size (unsigned int) (default: inf) maximum bit-vector size used by nla2bv tactic\\n    nla2bv_root (unsigned int) nla2bv tactic encodes reals into bit-vectors using expressions of the form a+b*sqrt(c), this parameter sets the value of c used in the encoding. (default: 2)\\n- normalize-bounds replace a variable x with lower bound k <= x with x' = x - k.\\n    norm_int_only (bool) normalize only the bounds of integer constants. (default: true)\\n    produce_models (bool) model generation. (default: false)\\n- pb2bv convert pseudo-boolean constraints to bit-vectors.\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    cardinality.encoding (symbol) encoding used for cardinality constraints: grouped, bimander, ordered, unate, circuit (default: none)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    keep_cardinality_constraints (bool) retain cardinality constraints (don't bit-blast them) and use built-in cardinality solver (default: false)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    pb.solver (symbol) encoding used for Pseudo-Boolean constraints: totalizer, sorting, binary_merge, bv, solver. PB constraints are retained if set to 'solver' (default: solver)\\n    pb2bv_all_clauses_limit (unsigned int) (default: 8) maximum number of literals for using equivalent CNF encoding of PB constraint.\\n    pb2bv_cardinality_limit (unsigned int) (default: inf) limit for using arc-consistent cardinality constraint encoding.\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n- propagate-ineqs propagate ineqs/bounds, remove subsumed inequalities.\\n    bound_max_refinements (unsigned int) (default: 16) maximum number of bound refinements (per round) for unbounded variables.\\n    bound_threshold (double) (default: 0.05) bound propagation improvement threshold ratio.\\n- purify-arith eliminate unnecessary operators: -, /, div, mod, rem, is-int, to-int, ^, root-objects.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    complete (bool) add constraints to make sure that any interpretation of a underspecified arithmetic operators is a function. The result will include additional uninterpreted functions/constants: /0, div0, mod0, 0^0, neg-root (default: true)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_inverses (bool) eliminate inverse trigonometric functions (asin, acos, atan). (default: true)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_root_objects (bool) eliminate root objects. (default: true)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    sk_hack (bool) hack for VCC (default: false)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n- recover-01 recover 0-1 variables hidden as Boolean variables.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    recover_01_max_bits (unsigned int) maximum number of bits to consider in a clause. (default: 10)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n- bit-blast reduce bit-vector expressions into SAT.\\n    blast_add (bool) bit-blast adders. (default: true)\\n    blast_full (bool) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms. (default: false)\\n    blast_mul (bool) bit-blast multipliers (and dividers, remainders). (default: true)\\n    blast_quant (bool) bit-blast quantified variables. (default: false)\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    max_steps (unsigned int) (default: infty) maximum number of steps. (default: 4294967295)\\n- bv1-blast reduce bit-vector expressions into bit-vectors of size 1 (notes: only equality, extract and concat are supported).\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    max_steps (unsigned int) (default: infty) maximum number of steps. (default: 4294967295)\\n- bv_bound_chk attempts to detect inconsistencies of bounds on bv expressions.\\n- propagate-bv-bounds propagate bit-vector bounds by simplifying implied or contradictory bounds.\\n    max_depth (unsigned int) maximum term depth. (default: 1024)\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    max_steps (unsigned int) (default: infty) maximum number of steps. (default: 4294967295)\\n    propagate_eq (bool) enable equality propagation from bounds. (default: false)\\n- propagate-bv-bounds2 propagate bit-vector bounds by simplifying implied or contradictory bounds.\\n    propagate_eq (bool) propagate equalities from inequalities (default: false)\\n- reduce-bv-size try to reduce bit-vector sizes using inequalities.\\n- bv-slice simplify using bit-vector slices.\\n- bvarray2uf Rewrite bit-vector arrays into bit-vector (uninterpreted) functions.\\n    produce_models (bool) model generation. (default: false)\\n- dt2bv eliminate finite domain data-types. Replace by bit-vectors.\\n- elim-small-bv eliminate small, quantified bit-vectors by expansion.\\n    max_bits (unsigned int) (default: 4) maximum bit-vector size of quantified bit-vectors to be eliminated.\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    max_steps (unsigned int) (default: infty) maximum number of steps. (default: 4294967295)\\n- max-bv-sharing use heuristics to maximize the sharing of bit-vector expressions such as adders and multipliers.\\n- blast-term-ite blast term if-then-else by hoisting them.\\n    max_inflation (unsigned int) (default: infinity) multiplicative factor of initial term size. (default: 4294967295)\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    max_steps (unsigned int) (default: infty) maximum number of steps. (default: 4294967295)\\n- cofactor-term-ite eliminate term if-the-else using cofactors.\\n    cofactor_equalities (bool) (default: true) use equalities to rewrite bodies of ite-expressions. This is potentially expensive.\\n- collect-statistics Collects various statistics.\\n- ctx-simplify apply contextual simplification rules.\\n    max_depth (unsigned int) maximum term depth. (default: 1024)\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    max_steps (unsigned int) (default: infty) maximum number of steps. (default: 4294967295)\\n    propagate_eq (bool) enable equality propagation from bounds. (default: false)\\n- demodulator extracts equalities from quantifiers and applies them to simplify.\\n- der destructive equality resolution.\\n- distribute-forall distribute forall over conjunctions.\\n- dom-simplify apply dominator simplification rules.\\n- elim-term-ite eliminate term if-then-else by adding fresh auxiliary declarations.\\n    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    max_steps (unsigned int) (default: infty) maximum number of steps. (default: 4294967295)\\n- elim-uncnstr2 eliminate unconstrained variables.\\n- elim-uncnstr eliminate application containing unconstrained variables.\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    max_steps (unsigned int) (default: infty) maximum number of steps. (default: 4294967295)\\n- elim-predicates eliminate predicates, macros and implicit definitions.\\n- injectivity Identifies and applies injectivity axioms.\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    produce_models (bool) model generation. (default: false)\\n- snf put goal in skolem normal form.\\n    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)\\n    sk_hack (bool) hack for VCC (default: false)\\n- nnf put goal in negation normal form.\\n    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)\\n    sk_hack (bool) hack for VCC (default: false)\\n- occf put goal in one constraint per clause normal form (notes: fails if proof generation is enabled; only clauses are considered).\\n- pb-preprocess pre-process pseudo-Boolean constraints a la Davis Putnam.\\n- propagate-values2 propagate constants.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n- propagate-values propagate constants.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n- reduce-args reduce the number of arguments of function applications, when for all occurrences of a function f the i-th is a value.\\n- reduce-args2 reduce the number of arguments of function applications, when for all occurrences of a function f the i-th is a value.\\n- simplify apply simplification rules.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n- elim-and convert (and a b) into (not (or (not a) (not b))).\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n- solve-eqs solve for variables.\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    theory_solver (bool) theory solvers. (default: true)\\n- special-relations detect and replace by special relations.\\n- split-clause split a clause in many subgoals.\\n    split_largest_clause (bool) (default: false) split the largest clause in the goal.\\n- symmetry-reduce apply symmetry reduction.\\n- tseitin-cnf convert goal into CNF using tseitin-like encoding (note: quantifiers are ignored).\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    common_patterns (bool) minimize the number of auxiliary variables during CNF encoding by identifying commonly used patterns (default: true)\\n    distributivity (bool) minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas (default: true)\\n    distributivity_blowup (unsigned int) maximum overhead for applying distributivity during CNF encoding (default: 32)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    ite_chaing (bool) minimize the number of auxiliary variables during CNF encoding by identifying if-then-else chains (default: true)\\n    ite_extra (bool) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n- tseitin-cnf-core convert goal into CNF using tseitin-like encoding (note: quantifiers are ignored). This tactic does not apply required simplifications to the input goal like the tseitin-cnf tactic.\\n    common_patterns (bool) minimize the number of auxiliary variables during CNF encoding by identifying commonly used patterns (default: true)\\n    distributivity (bool) minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas (default: true)\\n    distributivity_blowup (unsigned int) maximum overhead for applying distributivity during CNF encoding (default: 32)\\n    ite_chaing (bool) minimize the number of auxiliary variables during CNF encoding by identifying if-then-else chains (default: true)\\n    ite_extra (bool) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas (default: true)\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n- qffd builtin strategy for solving QF_FD problems.\\n    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)\\n    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)\\n    anf (bool) enable ANF based simplification in-processing (default: false)\\n    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)\\n    anf.exlin (bool) enable extended linear simplification (default: false)\\n    asymm_branch (bool) asymmetric branching (default: true)\\n    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)\\n    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)\\n    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)\\n    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)\\n    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)\\n    ate (bool) asymmetric tautology elimination (default: true)\\n    axioms2files (bool) print negated theory axioms to separate files during search (default: false)\\n    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)\\n    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)\\n    bca (bool) blocked clause addition - add blocked binary clauses (default: false)\\n    bce (bool) eliminate blocked clauses (default: false)\\n    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)\\n    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)\\n    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)\\n    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)\\n    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)\\n    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)\\n    cancel_backup_file (symbol) file to save partial search state if search is canceled (default: )\\n    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)\\n    cardinality.solver (bool) use cardinality solver (default: true)\\n    cce (bool) eliminate covered clauses (default: false)\\n    compact (bool) try to compact function graph (i.e., function interpretations that are lookup tables) (default: true)\\n    completion (bool) enable/disable model completion (default: false)\\n    core.minimize (bool) minimize computed core (default: false)\\n    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)\\n    ctrl_c (bool) enable interrupts from ctrl-c (default: true)\\n    cut (bool) enable AIG based simplification in-processing (default: false)\\n    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)\\n    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)\\n    cut.dont_cares (bool) integrate dont cares with cuts (default: true)\\n    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)\\n    cut.lut (bool) extract luts from clauses for cut simplification (default: false)\\n    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)\\n    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)\\n    cut.xor (bool) extract xors from clauses for cut simplification (default: false)\\n    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)\\n    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)\\n    ddfw.restart_base (unsigned int) number of flips used a starting point for hesitant restart backoff (default: 100000)\\n    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)\\n    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)\\n    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)\\n    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)\\n    drat.activity (bool) dump variable activities (default: false)\\n    drat.binary (bool) use Binary DRAT output format (default: false)\\n    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)\\n    drat.check_unsat (bool) build up internal proof and check (default: false)\\n    drat.disable (bool) override anything that enables DRAT (default: false)\\n    drat.file (symbol) file to dump DRAT proofs (default: )\\n    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)\\n    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)\\n    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)\\n    euf (bool) enable euf solver (this feature is preliminary and not ready for general consumption) (default: false)\\n    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)\\n    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)\\n    gc.burst (bool) perform eager garbage collection during initialization (default: false)\\n    gc.defrag (bool) defragment clauses when garbage collecting (default: true)\\n    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)\\n    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)\\n    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)\\n    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)\\n    inline_def (bool) inline local function definitions ignoring possible expansion (default: false)\\n    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)\\n    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )\\n    instantiations2console (bool) print quantifier instantiations to the console (default: false)\\n    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas\\n    keep_cardinality_constraints (bool) retain cardinality constraints (don't bit-blast them) and use built-in cardinality solver (default: false)\\n    lemmas2console (bool) print lemmas during search (default: false)\\n    local_search (bool) use local search instead of CDCL (default: false)\\n    local_search_dbg_flips (bool) write debug information for number of flips (default: false)\\n    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)\\n    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)\\n    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)\\n    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)\\n    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)\\n    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)\\n    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)\\n    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)\\n    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)\\n    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)\\n    lookahead.double (bool) enable double lookahead (default: true)\\n    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)\\n    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)\\n    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)\\n    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)\\n    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)\\n    lookahead_simplify (bool) use lookahead solver during simplification (default: false)\\n    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)\\n    max_conflicts (unsigned int) maximum number of conflicts (default: 4294967295)\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    minimize_lemmas (bool) minimize learned clauses (default: true)\\n    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)\\n    partial (bool) enable/disable partial function interpretations (default: false)\\n    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)\\n    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)\\n    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)\\n    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)\\n    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching, local_search (default: caching)\\n    phase.sticky (bool) use sticky phase caching (default: true)\\n    prob_search (bool) use probsat local search instead of CDCL (default: false)\\n    probing (bool) apply failed literal detection during simplification (default: true)\\n    probing_binary (bool) probe binary clauses (default: true)\\n    probing_cache (bool) add binary literals as lemmas (default: true)\\n    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)\\n    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)\\n    proof.check (bool) check proof logs (default: true)\\n    proof.check_rup (bool) check proof RUP inference in proof logs (default: true)\\n    proof.log (symbol) log clause proof trail into a file (default: )\\n    proof.save (bool) save proof log into a proof object that can be extracted using (get-proof) (default: false)\\n    proof.trim (bool) trim and save proof into a proof object that an be extracted using (get-proof) (default: false)\\n    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)\\n    random_freq (double) frequency of random case splits (default: 0.01)\\n    random_seed (unsigned int) random seed (default: 0)\\n    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)\\n    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)\\n    reorder.itau (double) inverse temperature for softmax (default: 4.0)\\n    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)\\n    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)\\n    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)\\n    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)\\n    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)\\n    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)\\n    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)\\n    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)\\n    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)\\n    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)\\n    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)\\n    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)\\n    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)\\n    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)\\n    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)\\n    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)\\n    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)\\n    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)\\n    rlimit (unsigned int) default resource limit used for solvers. Unrestricted when set to 0. (default: 0)\\n    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)\\n    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)\\n    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)\\n    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)\\n    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)\\n    slice (bool) use slice solver that filters assertions to use symbols occuring in @query formulas (default: false)\\n    smt (bool) use the SAT solver based incremental SMT core (default: false)\\n    smt.proof.check (bool) check proofs on the fly during SMT search (default: false)\\n    smtlib2_log (symbol) file to save solver interaction (default: )\\n    subsumption (bool) eliminate subsumed clauses (default: true)\\n    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)\\n    threads (unsigned int) number of parallel threads to use (default: 1)\\n    timeout (unsigned int) timeout on the solver object; overwrites a global timeout (default: 4294967295)\\n    user_functions (bool) include user defined functions in model (default: true)\\n    v1 (bool) use Z3 version 1.x pretty printer (default: false)\\n    v2 (bool) use Z3 version 2.x (x <= 16) pretty printer (default: false)\\n    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)\\n- pqffd builtin strategy for solving QF_FD problems in parallel.\\n- smtfd builtin strategy for solving SMT problems by reduction to FD.\\n    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)\\n    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)\\n    anf (bool) enable ANF based simplification in-processing (default: false)\\n    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)\\n    anf.exlin (bool) enable extended linear simplification (default: false)\\n    asymm_branch (bool) asymmetric branching (default: true)\\n    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)\\n    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)\\n    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)\\n    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)\\n    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)\\n    ate (bool) asymmetric tautology elimination (default: true)\\n    axioms2files (bool) print negated theory axioms to separate files during search (default: false)\\n    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)\\n    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)\\n    bca (bool) blocked clause addition - add blocked binary clauses (default: false)\\n    bce (bool) eliminate blocked clauses (default: false)\\n    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)\\n    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)\\n    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)\\n    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)\\n    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)\\n    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)\\n    cancel_backup_file (symbol) file to save partial search state if search is canceled (default: )\\n    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)\\n    cardinality.solver (bool) use cardinality solver (default: true)\\n    cce (bool) eliminate covered clauses (default: false)\\n    compact (bool) try to compact function graph (i.e., function interpretations that are lookup tables) (default: true)\\n    completion (bool) enable/disable model completion (default: false)\\n    core.minimize (bool) minimize computed core (default: false)\\n    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)\\n    ctrl_c (bool) enable interrupts from ctrl-c (default: true)\\n    cut (bool) enable AIG based simplification in-processing (default: false)\\n    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)\\n    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)\\n    cut.dont_cares (bool) integrate dont cares with cuts (default: true)\\n    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)\\n    cut.lut (bool) extract luts from clauses for cut simplification (default: false)\\n    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)\\n    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)\\n    cut.xor (bool) extract xors from clauses for cut simplification (default: false)\\n    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)\\n    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)\\n    ddfw.restart_base (unsigned int) number of flips used a starting point for hesitant restart backoff (default: 100000)\\n    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)\\n    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)\\n    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)\\n    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)\\n    drat.activity (bool) dump variable activities (default: false)\\n    drat.binary (bool) use Binary DRAT output format (default: false)\\n    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)\\n    drat.check_unsat (bool) build up internal proof and check (default: false)\\n    drat.disable (bool) override anything that enables DRAT (default: false)\\n    drat.file (symbol) file to dump DRAT proofs (default: )\\n    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)\\n    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)\\n    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)\\n    euf (bool) enable euf solver (this feature is preliminary and not ready for general consumption) (default: false)\\n    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)\\n    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)\\n    gc.burst (bool) perform eager garbage collection during initialization (default: false)\\n    gc.defrag (bool) defragment clauses when garbage collecting (default: true)\\n    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)\\n    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)\\n    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)\\n    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)\\n    inline_def (bool) inline local function definitions ignoring possible expansion (default: false)\\n    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)\\n    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )\\n    instantiations2console (bool) print quantifier instantiations to the console (default: false)\\n    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas\\n    keep_cardinality_constraints (bool) retain cardinality constraints (don't bit-blast them) and use built-in cardinality solver (default: false)\\n    lemmas2console (bool) print lemmas during search (default: false)\\n    local_search (bool) use local search instead of CDCL (default: false)\\n    local_search_dbg_flips (bool) write debug information for number of flips (default: false)\\n    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)\\n    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)\\n    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)\\n    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)\\n    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)\\n    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)\\n    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)\\n    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)\\n    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)\\n    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)\\n    lookahead.double (bool) enable double lookahead (default: true)\\n    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)\\n    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)\\n    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)\\n    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)\\n    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)\\n    lookahead_simplify (bool) use lookahead solver during simplification (default: false)\\n    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)\\n    max_lemmas (unsigned int) maximal number of lemmas per round (default: 10)\\n    max_conflicts (unsigned int) maximum number of conflicts (default: 4294967295)\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    minimize_lemmas (bool) minimize learned clauses (default: true)\\n    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)\\n    partial (bool) enable/disable partial function interpretations (default: false)\\n    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)\\n    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)\\n    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)\\n    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)\\n    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching, local_search (default: caching)\\n    phase.sticky (bool) use sticky phase caching (default: true)\\n    prob_search (bool) use probsat local search instead of CDCL (default: false)\\n    probing (bool) apply failed literal detection during simplification (default: true)\\n    probing_binary (bool) probe binary clauses (default: true)\\n    probing_cache (bool) add binary literals as lemmas (default: true)\\n    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)\\n    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)\\n    proof.check (bool) check proof logs (default: true)\\n    proof.check_rup (bool) check proof RUP inference in proof logs (default: true)\\n    proof.log (symbol) log clause proof trail into a file (default: )\\n    proof.save (bool) save proof log into a proof object that can be extracted using (get-proof) (default: false)\\n    proof.trim (bool) trim and save proof into a proof object that an be extracted using (get-proof) (default: false)\\n    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)\\n    random_freq (double) frequency of random case splits (default: 0.01)\\n    random_seed (unsigned int) random seed (default: 0)\\n    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)\\n    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)\\n    reorder.itau (double) inverse temperature for softmax (default: 4.0)\\n    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)\\n    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)\\n    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)\\n    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)\\n    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)\\n    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)\\n    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)\\n    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)\\n    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)\\n    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)\\n    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)\\n    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)\\n    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)\\n    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)\\n    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)\\n    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)\\n    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)\\n    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)\\n    rlimit (unsigned int) default resource limit used for solvers. Unrestricted when set to 0. (default: 0)\\n    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)\\n    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)\\n    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)\\n    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)\\n    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)\\n    slice (bool) use slice solver that filters assertions to use symbols occuring in @query formulas (default: false)\\n    smt (bool) use the SAT solver based incremental SMT core (default: false)\\n    smt.proof.check (bool) check proofs on the fly during SMT search (default: false)\\n    smtlib2_log (symbol) file to save solver interaction (default: )\\n    subsumption (bool) eliminate subsumed clauses (default: true)\\n    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)\\n    threads (unsigned int) number of parallel threads to use (default: 1)\\n    timeout (unsigned int) timeout on the solver object; overwrites a global timeout (default: 4294967295)\\n    user_functions (bool) include user defined functions in model (default: true)\\n    v1 (bool) use Z3 version 1.x pretty printer (default: false)\\n    v2 (bool) use Z3 version 2.x (x <= 16) pretty printer (default: false)\\n    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)\\n- fpa2bv convert floating point numbers to bit-vectors.\\n- qffp (try to) solve goal using the tactic for QF_FP.\\n    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)\\n    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    anf (bool) enable ANF based simplification in-processing (default: false)\\n    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)\\n    anf.exlin (bool) enable extended linear simplification (default: false)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    asymm_branch (bool) asymmetric branching (default: true)\\n    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)\\n    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)\\n    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)\\n    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)\\n    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)\\n    ate (bool) asymmetric tautology elimination (default: true)\\n    auto_config (bool) automatically configure solver (default: true)\\n    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)\\n    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)\\n    bca (bool) blocked clause addition - add blocked binary clauses (default: false)\\n    bce (bool) eliminate blocked clauses (default: false)\\n    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)\\n    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_add (bool) bit-blast adders. (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_full (bool) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms. (default: false)\\n    blast_mul (bool) bit-blast multipliers (and dividers, remainders). (default: true)\\n    blast_quant (bool) bit-blast quantified variables. (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)\\n    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)\\n    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)\\n    cardinality.solver (bool) use cardinality solver (default: true)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    cce (bool) eliminate covered clauses (default: false)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    cut (bool) enable AIG based simplification in-processing (default: false)\\n    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)\\n    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)\\n    cut.dont_cares (bool) integrate dont cares with cuts (default: true)\\n    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)\\n    cut.lut (bool) extract luts from clauses for cut simplification (default: false)\\n    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)\\n    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)\\n    cut.xor (bool) extract xors from clauses for cut simplification (default: false)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)\\n    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)\\n    ddfw.restart_base (unsigned int) number of flips used a starting point for hesitant restart backoff (default: 100000)\\n    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)\\n    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)\\n    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)\\n    div0_ackermann_limit (unsigned int) a bound for number of congruence Ackermann lemmas for div0 modelling (default: 1000)\\n    drat.activity (bool) dump variable activities (default: false)\\n    drat.binary (bool) use Binary DRAT output format (default: false)\\n    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)\\n    drat.check_unsat (bool) build up internal proof and check (default: false)\\n    drat.disable (bool) override anything that enables DRAT (default: false)\\n    drat.file (symbol) file to dump DRAT proofs (default: )\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    euf (bool) enable euf solver (this feature is preliminary and not ready for general consumption) (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)\\n    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)\\n    gc.burst (bool) perform eager garbage collection during initialization (default: false)\\n    gc.defrag (bool) defragment clauses when garbage collecting (default: true)\\n    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)\\n    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)\\n    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)\\n    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)\\n    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )\\n    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    learned (bool) (default: false) collect also learned clauses.\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    local_search (bool) use local search instead of CDCL (default: false)\\n    local_search_dbg_flips (bool) write debug information for number of flips (default: false)\\n    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)\\n    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)\\n    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)\\n    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)\\n    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)\\n    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)\\n    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)\\n    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)\\n    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)\\n    lookahead.double (bool) enable double lookahead (default: true)\\n    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)\\n    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)\\n    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)\\n    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)\\n    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)\\n    lookahead_simplify (bool) use lookahead solver during simplification (default: false)\\n    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    minimize_lemmas (bool) minimize learned clauses (default: true)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)\\n    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)\\n    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)\\n    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)\\n    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching, local_search (default: caching)\\n    phase.sticky (bool) use sticky phase caching (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    prob_search (bool) use probsat local search instead of CDCL (default: false)\\n    probing (bool) apply failed literal detection during simplification (default: true)\\n    probing_binary (bool) probe binary clauses (default: true)\\n    probing_cache (bool) add binary literals as lemmas (default: true)\\n    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)\\n    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)\\n    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_freq (double) frequency of random case splits (default: 0.01)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)\\n    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)\\n    reorder.itau (double) inverse temperature for softmax (default: 4.0)\\n    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)\\n    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)\\n    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)\\n    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)\\n    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)\\n    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)\\n    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)\\n    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)\\n    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)\\n    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)\\n    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)\\n    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)\\n    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)\\n    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)\\n    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)\\n    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)\\n    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)\\n    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)\\n    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)\\n    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)\\n    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    smt (bool) use the SAT solver based incremental SMT core (default: false)\\n    smt.proof.check (bool) check proofs on the fly during SMT search (default: false)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    subsumption (bool) eliminate subsumed clauses (default: true)\\n    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)\\n- qffpbv (try to) solve goal using the tactic for QF_FPBV (floats+bit-vectors).\\n    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)\\n    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    anf (bool) enable ANF based simplification in-processing (default: false)\\n    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)\\n    anf.exlin (bool) enable extended linear simplification (default: false)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    asymm_branch (bool) asymmetric branching (default: true)\\n    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)\\n    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)\\n    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)\\n    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)\\n    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)\\n    ate (bool) asymmetric tautology elimination (default: true)\\n    auto_config (bool) automatically configure solver (default: true)\\n    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)\\n    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)\\n    bca (bool) blocked clause addition - add blocked binary clauses (default: false)\\n    bce (bool) eliminate blocked clauses (default: false)\\n    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)\\n    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_add (bool) bit-blast adders. (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_full (bool) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms. (default: false)\\n    blast_mul (bool) bit-blast multipliers (and dividers, remainders). (default: true)\\n    blast_quant (bool) bit-blast quantified variables. (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)\\n    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)\\n    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)\\n    cardinality.solver (bool) use cardinality solver (default: true)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    cce (bool) eliminate covered clauses (default: false)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    cut (bool) enable AIG based simplification in-processing (default: false)\\n    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)\\n    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)\\n    cut.dont_cares (bool) integrate dont cares with cuts (default: true)\\n    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)\\n    cut.lut (bool) extract luts from clauses for cut simplification (default: false)\\n    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)\\n    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)\\n    cut.xor (bool) extract xors from clauses for cut simplification (default: false)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)\\n    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)\\n    ddfw.restart_base (unsigned int) number of flips used a starting point for hesitant restart backoff (default: 100000)\\n    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)\\n    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)\\n    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)\\n    div0_ackermann_limit (unsigned int) a bound for number of congruence Ackermann lemmas for div0 modelling (default: 1000)\\n    drat.activity (bool) dump variable activities (default: false)\\n    drat.binary (bool) use Binary DRAT output format (default: false)\\n    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)\\n    drat.check_unsat (bool) build up internal proof and check (default: false)\\n    drat.disable (bool) override anything that enables DRAT (default: false)\\n    drat.file (symbol) file to dump DRAT proofs (default: )\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    euf (bool) enable euf solver (this feature is preliminary and not ready for general consumption) (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)\\n    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)\\n    gc.burst (bool) perform eager garbage collection during initialization (default: false)\\n    gc.defrag (bool) defragment clauses when garbage collecting (default: true)\\n    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)\\n    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)\\n    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)\\n    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)\\n    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )\\n    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    learned (bool) (default: false) collect also learned clauses.\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    local_search (bool) use local search instead of CDCL (default: false)\\n    local_search_dbg_flips (bool) write debug information for number of flips (default: false)\\n    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)\\n    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)\\n    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)\\n    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)\\n    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)\\n    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)\\n    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)\\n    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)\\n    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)\\n    lookahead.double (bool) enable double lookahead (default: true)\\n    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)\\n    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)\\n    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)\\n    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)\\n    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)\\n    lookahead_simplify (bool) use lookahead solver during simplification (default: false)\\n    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    minimize_lemmas (bool) minimize learned clauses (default: true)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)\\n    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)\\n    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)\\n    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)\\n    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching, local_search (default: caching)\\n    phase.sticky (bool) use sticky phase caching (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    prob_search (bool) use probsat local search instead of CDCL (default: false)\\n    probing (bool) apply failed literal detection during simplification (default: true)\\n    probing_binary (bool) probe binary clauses (default: true)\\n    probing_cache (bool) add binary literals as lemmas (default: true)\\n    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)\\n    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)\\n    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_freq (double) frequency of random case splits (default: 0.01)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)\\n    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)\\n    reorder.itau (double) inverse temperature for softmax (default: 4.0)\\n    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)\\n    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)\\n    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)\\n    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)\\n    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)\\n    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)\\n    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)\\n    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)\\n    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)\\n    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)\\n    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)\\n    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)\\n    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)\\n    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)\\n    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)\\n    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)\\n    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)\\n    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)\\n    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)\\n    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)\\n    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    smt (bool) use the SAT solver based incremental SMT core (default: false)\\n    smt.proof.check (bool) check proofs on the fly during SMT search (default: false)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    subsumption (bool) eliminate subsumed clauses (default: true)\\n    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)\\n- qffplra (try to) solve goal using the tactic for QF_FPLRA.\\n    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)\\n    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    anf (bool) enable ANF based simplification in-processing (default: false)\\n    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)\\n    anf.exlin (bool) enable extended linear simplification (default: false)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    asymm_branch (bool) asymmetric branching (default: true)\\n    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)\\n    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)\\n    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)\\n    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)\\n    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)\\n    ate (bool) asymmetric tautology elimination (default: true)\\n    auto_config (bool) automatically configure solver (default: true)\\n    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)\\n    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)\\n    bca (bool) blocked clause addition - add blocked binary clauses (default: false)\\n    bce (bool) eliminate blocked clauses (default: false)\\n    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)\\n    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_add (bool) bit-blast adders. (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_full (bool) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms. (default: false)\\n    blast_mul (bool) bit-blast multipliers (and dividers, remainders). (default: true)\\n    blast_quant (bool) bit-blast quantified variables. (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)\\n    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)\\n    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)\\n    cardinality.solver (bool) use cardinality solver (default: true)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    cce (bool) eliminate covered clauses (default: false)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    cut (bool) enable AIG based simplification in-processing (default: false)\\n    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)\\n    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)\\n    cut.dont_cares (bool) integrate dont cares with cuts (default: true)\\n    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)\\n    cut.lut (bool) extract luts from clauses for cut simplification (default: false)\\n    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)\\n    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)\\n    cut.xor (bool) extract xors from clauses for cut simplification (default: false)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)\\n    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)\\n    ddfw.restart_base (unsigned int) number of flips used a starting point for hesitant restart backoff (default: 100000)\\n    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)\\n    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)\\n    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)\\n    div0_ackermann_limit (unsigned int) a bound for number of congruence Ackermann lemmas for div0 modelling (default: 1000)\\n    drat.activity (bool) dump variable activities (default: false)\\n    drat.binary (bool) use Binary DRAT output format (default: false)\\n    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)\\n    drat.check_unsat (bool) build up internal proof and check (default: false)\\n    drat.disable (bool) override anything that enables DRAT (default: false)\\n    drat.file (symbol) file to dump DRAT proofs (default: )\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    euf (bool) enable euf solver (this feature is preliminary and not ready for general consumption) (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)\\n    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)\\n    gc.burst (bool) perform eager garbage collection during initialization (default: false)\\n    gc.defrag (bool) defragment clauses when garbage collecting (default: true)\\n    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)\\n    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)\\n    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)\\n    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)\\n    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )\\n    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    learned (bool) (default: false) collect also learned clauses.\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    local_search (bool) use local search instead of CDCL (default: false)\\n    local_search_dbg_flips (bool) write debug information for number of flips (default: false)\\n    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)\\n    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)\\n    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)\\n    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)\\n    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)\\n    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)\\n    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)\\n    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)\\n    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)\\n    lookahead.double (bool) enable double lookahead (default: true)\\n    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)\\n    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)\\n    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)\\n    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)\\n    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)\\n    lookahead_simplify (bool) use lookahead solver during simplification (default: false)\\n    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    minimize_lemmas (bool) minimize learned clauses (default: true)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)\\n    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)\\n    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)\\n    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)\\n    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching, local_search (default: caching)\\n    phase.sticky (bool) use sticky phase caching (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    prob_search (bool) use probsat local search instead of CDCL (default: false)\\n    probing (bool) apply failed literal detection during simplification (default: true)\\n    probing_binary (bool) probe binary clauses (default: true)\\n    probing_cache (bool) add binary literals as lemmas (default: true)\\n    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)\\n    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)\\n    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_freq (double) frequency of random case splits (default: 0.01)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)\\n    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)\\n    reorder.itau (double) inverse temperature for softmax (default: 4.0)\\n    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)\\n    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)\\n    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)\\n    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)\\n    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)\\n    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)\\n    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)\\n    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)\\n    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)\\n    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)\\n    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)\\n    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)\\n    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)\\n    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)\\n    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)\\n    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)\\n    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)\\n    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)\\n    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)\\n    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)\\n    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    smt (bool) use the SAT solver based incremental SMT core (default: false)\\n    smt.proof.check (bool) check proofs on the fly during SMT search (default: false)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    subsumption (bool) eliminate subsumed clauses (default: true)\\n    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)\\n- default default strategy used when no logic is specified.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    compile_equality (bool) (default:false) compile equalities into pseudo-Boolean equality\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_depth (unsigned int) maximum term depth. (default: 1024)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    propagate_eq (bool) enable equality propagation from bounds. (default: false)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n- euf-completion simplify using equalities.\\n- solver-subsumption remove assertions that are subsumed.\\n    max_conflicts (unsigned int) (default: 2) maximal number of conflicts allowed per solver call.\\n- qfbv-sls (try to) solve using stochastic local search for QF_BV.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith_allow_plateau (bool) allow plateau moves during NIRA solving (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    arith_use_clausal_lookahead (bool) use clause based lookahead for NIRA (default: false)\\n    arith_use_lookahead (bool) use lookahead solver for NIRA (default: true)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bv_allow_rotation (bool) allow model rotation when repairing literal assignment (default: true)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    bv_use_lookahead (bool) use lookahead solver for BV (default: true)\\n    bv_use_top_level_assertions (bool) use top-level assertions for BV lookahead solver (default: true)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    dt_axiomatic (bool) use axiomatic mode or model reduction for datatype solver (default: true)\\n    early_prune (bool) use early pruning for score prediction (default: true)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_repairs (unsigned int) maximum number of repairs before restart (default: 1000)\\n    max_restarts (unsigned int) maximum number of restarts (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    paws_init (unsigned int) initial/minimum assertion weights (default: 40)\\n    paws_sp (unsigned int) smooth assertion weights with probability paws_sp / 1024 (default: 52)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    random_offset (bool) use random offset for candidate evaluation (default: true)\\n    random_seed (unsigned int) random seed (default: 0)\\n    rescore (bool) rescore/normalize top-level score every base restart interval (default: true)\\n    restart_base (unsigned int) base restart interval given by moves per run (default: 100)\\n    restart_init (bool) initialize to 0 or random value (= 1) after restart (default: false)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    scale_unsat (double) scale score of unsat expressions by this factor (default: 0.5)\\n    sk_hack (bool) hack for VCC (default: false)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str_update_strategy (unsigned int) string update candidate selection: 0 - single character based update, 1 - subsequence based update, 2 - combined (default: 2)\\n    theory_solver (bool) theory solvers. (default: true)\\n    track_unsat (bool) keep a list of unsat assertions as done in SAT - currently disabled internally (default: false)\\n    vns_mc (unsigned int) in local minima, try Monte Carlo sampling vns_mc many 2-bit-flips per bit (default: 0)\\n    vns_repick (bool) in local minima, try picking a different assertion (only for walksat) (default: false)\\n    walksat (bool) use walksat assertion selection (instead of gsat) (default: true)\\n    walksat_repick (bool) repick assertion if randomizing in local minima (default: true)\\n    walksat_ucb (bool) use bandit heuristic for walksat assertion selection (instead of random) (default: true)\\n    walksat_ucb_constant (double) the ucb constant c in the term score + c * f(touched) (default: 20.0)\\n    walksat_ucb_forget (double) scale touched by this factor every base restart interval (default: 1.0)\\n    walksat_ucb_init (bool) initialize total ucb touched to formula size (default: false)\\n    walksat_ucb_noise (double) add noise 0 <= 256 * ucb_noise to ucb score for assertion selection (default: 0.0002)\\n    wp (unsigned int) random walk with probability wp / 1024 (default: 100)\\n- sls-smt (try to) solve SMT formulas using local search.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith_allow_plateau (bool) allow plateau moves during NIRA solving (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    arith_use_clausal_lookahead (bool) use clause based lookahead for NIRA (default: false)\\n    arith_use_lookahead (bool) use lookahead solver for NIRA (default: true)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bv_allow_rotation (bool) allow model rotation when repairing literal assignment (default: true)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    bv_use_lookahead (bool) use lookahead solver for BV (default: true)\\n    bv_use_top_level_assertions (bool) use top-level assertions for BV lookahead solver (default: true)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    dt_axiomatic (bool) use axiomatic mode or model reduction for datatype solver (default: true)\\n    early_prune (bool) use early pruning for score prediction (default: true)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_repairs (unsigned int) maximum number of repairs before restart (default: 1000)\\n    max_restarts (unsigned int) maximum number of restarts (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    paws_init (unsigned int) initial/minimum assertion weights (default: 40)\\n    paws_sp (unsigned int) smooth assertion weights with probability paws_sp / 1024 (default: 52)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    random_offset (bool) use random offset for candidate evaluation (default: true)\\n    random_seed (unsigned int) random seed (default: 0)\\n    rescore (bool) rescore/normalize top-level score every base restart interval (default: true)\\n    restart_base (unsigned int) base restart interval given by moves per run (default: 100)\\n    restart_init (bool) initialize to 0 or random value (= 1) after restart (default: false)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    scale_unsat (double) scale score of unsat expressions by this factor (default: 0.5)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str_update_strategy (unsigned int) string update candidate selection: 0 - single character based update, 1 - subsequence based update, 2 - combined (default: 2)\\n    theory_solver (bool) theory solvers. (default: true)\\n    track_unsat (bool) keep a list of unsat assertions as done in SAT - currently disabled internally (default: false)\\n    vns_mc (unsigned int) in local minima, try Monte Carlo sampling vns_mc many 2-bit-flips per bit (default: 0)\\n    vns_repick (bool) in local minima, try picking a different assertion (only for walksat) (default: false)\\n    walksat (bool) use walksat assertion selection (instead of gsat) (default: true)\\n    walksat_repick (bool) repick assertion if randomizing in local minima (default: true)\\n    walksat_ucb (bool) use bandit heuristic for walksat assertion selection (instead of random) (default: true)\\n    walksat_ucb_constant (double) the ucb constant c in the term score + c * f(touched) (default: 20.0)\\n    walksat_ucb_forget (double) scale touched by this factor every base restart interval (default: 1.0)\\n    walksat_ucb_init (bool) initialize total ucb touched to formula size (default: false)\\n    walksat_ucb_noise (double) add noise 0 <= 256 * ucb_noise to ucb score for assertion selection (default: 0.0002)\\n    wp (unsigned int) random walk with probability wp / 1024 (default: 100)\\n- nra builtin strategy for solving NRA problems.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    cell_sample (bool) cell sample projection (default: true)\\n    check_lemmas (bool) check lemmas on the fly using an independent nlsat solver (default: false)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    common_patterns (bool) minimize the number of auxiliary variables during CNF encoding by identifying commonly used patterns (default: true)\\n    complete (bool) add constraints to make sure that any interpretation of a underspecified arithmetic operators is a function. The result will include additional uninterpreted functions/constants: /0, div0, mod0, 0^0, neg-root (default: true)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    distributivity (bool) minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas (default: true)\\n    distributivity_blowup (unsigned int) maximum overhead for applying distributivity during CNF encoding (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_inverses (bool) eliminate inverse trigonometric functions (asin, acos, atan). (default: true)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_root_objects (bool) eliminate root objects. (default: true)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    factor (bool) (default: true) factor polynomials.\\n    factor_max_prime (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step (default: 31)\\n    factor_num_primes (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifting and searching (default: 1)\\n    factor_search_size (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space (default: 5000)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    inline_vars (bool) inline variables that can be isolated from equations (not supported in incremental mode) (default: false)\\n    ite_chaing (bool) minimize the number of auxiliary variables during CNF encoding by identifying if-then-else chains (default: true)\\n    ite_extra (bool) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    lazy (unsigned int) how lazy the solver is. (default: 0)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    log_lemmas (bool) display lemmas as self-contained SMT formulas (default: false)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.\\n    max_conflicts (unsigned int) maximum number of conflicts. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_prime (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step.\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_search_size (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space.\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    min_mag (unsigned int) Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16 (default: 16)\\n    minimize_conflicts (bool) minimize conflicts (default: false)\\n    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    num_primes (unsigned int) (default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching.\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    randomize (bool) randomize selection of a witness in nlsat. (default: true)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    reorder (bool) reorder variables. (default: true)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    seed (unsigned int) random seed. (default: 0)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    shuffle_vars (bool) use a random variable order. (default: false)\\n    simple_check (bool) precheck polynomials using variables sign (default: false)\\n    simplify_conflicts (bool) simplify conflicts using equalities before resolving them in nlsat solver. (default: true)\\n    sk_hack (bool) hack for VCC (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    split_factors (bool) apply simplifications such as (= (* p1 p2) 0) --\x3e (or (= p1 0) (= p2 0)). (default: true)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n    variable_ordering_strategy (unsigned int) Variable Ordering Strategy, 0 for none, 1 for BROWN, 2 for TRIANGULAR, 3 for ONLYPOLY (default: 0)\\n    zero_accuracy (unsigned int) one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k) (default: 0)\\n- qfaufbv builtin strategy for solving QF_AUFBV problems.\\n    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)\\n    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    anf (bool) enable ANF based simplification in-processing (default: false)\\n    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)\\n    anf.exlin (bool) enable extended linear simplification (default: false)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    asymm_branch (bool) asymmetric branching (default: true)\\n    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)\\n    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)\\n    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)\\n    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)\\n    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)\\n    ate (bool) asymmetric tautology elimination (default: true)\\n    auto_config (bool) automatically configure solver (default: true)\\n    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)\\n    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)\\n    bca (bool) blocked clause addition - add blocked binary clauses (default: false)\\n    bce (bool) eliminate blocked clauses (default: false)\\n    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)\\n    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_add (bool) bit-blast adders. (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_full (bool) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms. (default: false)\\n    blast_mul (bool) bit-blast multipliers (and dividers, remainders). (default: true)\\n    blast_quant (bool) bit-blast quantified variables. (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)\\n    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)\\n    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)\\n    cardinality.solver (bool) use cardinality solver (default: true)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    cce (bool) eliminate covered clauses (default: false)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    cut (bool) enable AIG based simplification in-processing (default: false)\\n    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)\\n    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)\\n    cut.dont_cares (bool) integrate dont cares with cuts (default: true)\\n    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)\\n    cut.lut (bool) extract luts from clauses for cut simplification (default: false)\\n    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)\\n    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)\\n    cut.xor (bool) extract xors from clauses for cut simplification (default: false)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)\\n    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)\\n    ddfw.restart_base (unsigned int) number of flips used a starting point for hesitant restart backoff (default: 100000)\\n    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)\\n    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)\\n    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)\\n    div0_ackermann_limit (unsigned int) a bound for number of congruence Ackermann lemmas for div0 modelling (default: 1000)\\n    drat.activity (bool) dump variable activities (default: false)\\n    drat.binary (bool) use Binary DRAT output format (default: false)\\n    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)\\n    drat.check_unsat (bool) build up internal proof and check (default: false)\\n    drat.disable (bool) override anything that enables DRAT (default: false)\\n    drat.file (symbol) file to dump DRAT proofs (default: )\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    euf (bool) enable euf solver (this feature is preliminary and not ready for general consumption) (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)\\n    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)\\n    gc.burst (bool) perform eager garbage collection during initialization (default: false)\\n    gc.defrag (bool) defragment clauses when garbage collecting (default: true)\\n    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)\\n    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)\\n    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)\\n    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)\\n    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )\\n    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    learned (bool) (default: false) collect also learned clauses.\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    local_search (bool) use local search instead of CDCL (default: false)\\n    local_search_dbg_flips (bool) write debug information for number of flips (default: false)\\n    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)\\n    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)\\n    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)\\n    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)\\n    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)\\n    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)\\n    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)\\n    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)\\n    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)\\n    lookahead.double (bool) enable double lookahead (default: true)\\n    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)\\n    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)\\n    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)\\n    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)\\n    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)\\n    lookahead_simplify (bool) use lookahead solver during simplification (default: false)\\n    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    minimize_lemmas (bool) minimize learned clauses (default: true)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)\\n    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)\\n    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)\\n    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)\\n    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching, local_search (default: caching)\\n    phase.sticky (bool) use sticky phase caching (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    prob_search (bool) use probsat local search instead of CDCL (default: false)\\n    probing (bool) apply failed literal detection during simplification (default: true)\\n    probing_binary (bool) probe binary clauses (default: true)\\n    probing_cache (bool) add binary literals as lemmas (default: true)\\n    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)\\n    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)\\n    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_freq (double) frequency of random case splits (default: 0.01)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)\\n    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)\\n    reorder.itau (double) inverse temperature for softmax (default: 4.0)\\n    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)\\n    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)\\n    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)\\n    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)\\n    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)\\n    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)\\n    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)\\n    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)\\n    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)\\n    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)\\n    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)\\n    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)\\n    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)\\n    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)\\n    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)\\n    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)\\n    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)\\n    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)\\n    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)\\n    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)\\n    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    smt (bool) use the SAT solver based incremental SMT core (default: false)\\n    smt.proof.check (bool) check proofs on the fly during SMT search (default: false)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    subsumption (bool) eliminate subsumed clauses (default: true)\\n    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)\\n- qfauflia builtin strategy for solving QF_AUFLIA problems.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n- qfbv builtin strategy for solving QF_BV problems.\\n    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)\\n    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    anf (bool) enable ANF based simplification in-processing (default: false)\\n    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)\\n    anf.exlin (bool) enable extended linear simplification (default: false)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    asymm_branch (bool) asymmetric branching (default: true)\\n    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)\\n    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)\\n    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)\\n    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)\\n    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)\\n    ate (bool) asymmetric tautology elimination (default: true)\\n    auto_config (bool) automatically configure solver (default: true)\\n    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)\\n    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)\\n    bca (bool) blocked clause addition - add blocked binary clauses (default: false)\\n    bce (bool) eliminate blocked clauses (default: false)\\n    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)\\n    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_add (bool) bit-blast adders. (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_full (bool) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms. (default: false)\\n    blast_mul (bool) bit-blast multipliers (and dividers, remainders). (default: true)\\n    blast_quant (bool) bit-blast quantified variables. (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)\\n    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)\\n    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)\\n    cardinality.solver (bool) use cardinality solver (default: true)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    cce (bool) eliminate covered clauses (default: false)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    cut (bool) enable AIG based simplification in-processing (default: false)\\n    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)\\n    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)\\n    cut.dont_cares (bool) integrate dont cares with cuts (default: true)\\n    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)\\n    cut.lut (bool) extract luts from clauses for cut simplification (default: false)\\n    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)\\n    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)\\n    cut.xor (bool) extract xors from clauses for cut simplification (default: false)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)\\n    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)\\n    ddfw.restart_base (unsigned int) number of flips used a starting point for hesitant restart backoff (default: 100000)\\n    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)\\n    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)\\n    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)\\n    div0_ackermann_limit (unsigned int) a bound for number of congruence Ackermann lemmas for div0 modelling (default: 1000)\\n    drat.activity (bool) dump variable activities (default: false)\\n    drat.binary (bool) use Binary DRAT output format (default: false)\\n    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)\\n    drat.check_unsat (bool) build up internal proof and check (default: false)\\n    drat.disable (bool) override anything that enables DRAT (default: false)\\n    drat.file (symbol) file to dump DRAT proofs (default: )\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    euf (bool) enable euf solver (this feature is preliminary and not ready for general consumption) (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)\\n    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)\\n    gc.burst (bool) perform eager garbage collection during initialization (default: false)\\n    gc.defrag (bool) defragment clauses when garbage collecting (default: true)\\n    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)\\n    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)\\n    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)\\n    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)\\n    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )\\n    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    learned (bool) (default: false) collect also learned clauses.\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    local_search (bool) use local search instead of CDCL (default: false)\\n    local_search_dbg_flips (bool) write debug information for number of flips (default: false)\\n    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)\\n    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)\\n    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)\\n    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)\\n    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)\\n    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)\\n    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)\\n    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)\\n    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)\\n    lookahead.double (bool) enable double lookahead (default: true)\\n    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)\\n    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)\\n    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)\\n    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)\\n    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)\\n    lookahead_simplify (bool) use lookahead solver during simplification (default: false)\\n    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    minimize_lemmas (bool) minimize learned clauses (default: true)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)\\n    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)\\n    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)\\n    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)\\n    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching, local_search (default: caching)\\n    phase.sticky (bool) use sticky phase caching (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    prob_search (bool) use probsat local search instead of CDCL (default: false)\\n    probing (bool) apply failed literal detection during simplification (default: true)\\n    probing_binary (bool) probe binary clauses (default: true)\\n    probing_cache (bool) add binary literals as lemmas (default: true)\\n    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)\\n    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)\\n    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_freq (double) frequency of random case splits (default: 0.01)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)\\n    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)\\n    reorder.itau (double) inverse temperature for softmax (default: 4.0)\\n    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)\\n    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)\\n    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)\\n    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)\\n    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)\\n    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)\\n    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)\\n    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)\\n    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)\\n    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)\\n    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)\\n    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)\\n    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)\\n    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)\\n    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)\\n    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)\\n    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)\\n    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)\\n    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)\\n    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)\\n    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    smt (bool) use the SAT solver based incremental SMT core (default: false)\\n    smt.proof.check (bool) check proofs on the fly during SMT search (default: false)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    subsumption (bool) eliminate subsumed clauses (default: true)\\n    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)\\n- qfidl builtin strategy for solving QF_IDL problems.\\n    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)\\n    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    anf (bool) enable ANF based simplification in-processing (default: false)\\n    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)\\n    anf.exlin (bool) enable extended linear simplification (default: false)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    asymm_branch (bool) asymmetric branching (default: true)\\n    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)\\n    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)\\n    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)\\n    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)\\n    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)\\n    ate (bool) asymmetric tautology elimination (default: true)\\n    auto_config (bool) automatically configure solver (default: true)\\n    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)\\n    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)\\n    bca (bool) blocked clause addition - add blocked binary clauses (default: false)\\n    bce (bool) eliminate blocked clauses (default: false)\\n    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)\\n    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_add (bool) bit-blast adders. (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_full (bool) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms. (default: false)\\n    blast_mul (bool) bit-blast multipliers (and dividers, remainders). (default: true)\\n    blast_quant (bool) bit-blast quantified variables. (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)\\n    bound_max_refinements (unsigned int) (default: 16) maximum number of bound refinements (per round) for unbounded variables.\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bound_threshold (double) (default: 0.05) bound propagation improvement threshold ratio.\\n    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)\\n    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)\\n    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    cardinality.encoding (symbol) encoding used for cardinality constraints: grouped, bimander, ordered, unate, circuit (default: none)\\n    cardinality.solver (bool) use cardinality solver (default: true)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    cce (bool) eliminate covered clauses (default: false)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize computed core (default: false)\\n    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    cut (bool) enable AIG based simplification in-processing (default: false)\\n    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)\\n    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)\\n    cut.dont_cares (bool) integrate dont cares with cuts (default: true)\\n    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)\\n    cut.lut (bool) extract luts from clauses for cut simplification (default: false)\\n    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)\\n    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)\\n    cut.xor (bool) extract xors from clauses for cut simplification (default: false)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)\\n    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)\\n    ddfw.restart_base (unsigned int) number of flips used a starting point for hesitant restart backoff (default: 100000)\\n    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)\\n    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)\\n    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    diff_neq_max_k (unsigned int) maximum variable upper bound for diff neq solver. (default: 1024)\\n    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)\\n    drat.activity (bool) dump variable activities (default: false)\\n    drat.binary (bool) use Binary DRAT output format (default: false)\\n    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)\\n    drat.check_unsat (bool) build up internal proof and check (default: false)\\n    drat.disable (bool) override anything that enables DRAT (default: false)\\n    drat.file (symbol) file to dump DRAT proofs (default: )\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    euf (bool) enable euf solver (this feature is preliminary and not ready for general consumption) (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)\\n    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)\\n    gc.burst (bool) perform eager garbage collection during initialization (default: false)\\n    gc.defrag (bool) defragment clauses when garbage collecting (default: true)\\n    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)\\n    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)\\n    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)\\n    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)\\n    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )\\n    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    keep_cardinality_constraints (bool) retain cardinality constraints (don't bit-blast them) and use built-in cardinality solver (default: false)\\n    learned (bool) (default: false) collect also learned clauses.\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    lia2pb_max_bits (unsigned int) (default: 32) maximum number of bits to be used (per variable) in lia2pb.\\n    lia2pb_partial (bool) (default: false) partial lia2pb conversion.\\n    lia2pb_total_bits (unsigned int) (default: 2048) total number of bits to be used (per problem) in lia2pb.\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    local_search (bool) use local search instead of CDCL (default: false)\\n    local_search_dbg_flips (bool) write debug information for number of flips (default: false)\\n    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)\\n    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)\\n    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)\\n    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)\\n    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)\\n    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)\\n    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)\\n    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)\\n    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)\\n    lookahead.double (bool) enable double lookahead (default: true)\\n    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)\\n    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)\\n    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)\\n    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)\\n    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)\\n    lookahead_simplify (bool) use lookahead solver during simplification (default: false)\\n    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    minimize_lemmas (bool) minimize learned clauses (default: true)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    norm_int_only (bool) normalize only the bounds of integer constants. (default: true)\\n    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)\\n    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)\\n    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)\\n    pb.solver (symbol) encoding used for Pseudo-Boolean constraints: totalizer, sorting, binary_merge, bv, solver. PB constraints are retained if set to 'solver' (default: solver)\\n    pb2bv_all_clauses_limit (unsigned int) (default: 8) maximum number of literals for using equivalent CNF encoding of PB constraint.\\n    pb2bv_cardinality_limit (unsigned int) (default: inf) limit for using arc-consistent cardinality constraint encoding.\\n    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching, local_search (default: caching)\\n    phase.sticky (bool) use sticky phase caching (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    prob_search (bool) use probsat local search instead of CDCL (default: false)\\n    probing (bool) apply failed literal detection during simplification (default: true)\\n    probing_binary (bool) probe binary clauses (default: true)\\n    probing_cache (bool) add binary literals as lemmas (default: true)\\n    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)\\n    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)\\n    produce_models (bool) model generation. (default: false)\\n    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_freq (double) frequency of random case splits (default: 0.01)\\n    random_seed (unsigned int) random seed (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)\\n    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)\\n    reorder.itau (double) inverse temperature for softmax (default: 4.0)\\n    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)\\n    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)\\n    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)\\n    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)\\n    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)\\n    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)\\n    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)\\n    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)\\n    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)\\n    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)\\n    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)\\n    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)\\n    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)\\n    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)\\n    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)\\n    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)\\n    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)\\n    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)\\n    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)\\n    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)\\n    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    smt (bool) use the SAT solver based incremental SMT core (default: false)\\n    smt.proof.check (bool) check proofs on the fly during SMT search (default: false)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    subsumption (bool) eliminate subsumed clauses (default: true)\\n    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) number of parallel threads to use (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)\\n- qflia builtin strategy for solving QF_LIA problems.\\n    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)\\n    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)\\n    add_bound_lower (rational) (default: -2) lower bound to be added to unbounded variables.\\n    add_bound_upper (rational) (default: 2) upper bound to be added to unbounded variables.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    anf (bool) enable ANF based simplification in-processing (default: false)\\n    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)\\n    anf.exlin (bool) enable extended linear simplification (default: false)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    asymm_branch (bool) asymmetric branching (default: true)\\n    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)\\n    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)\\n    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)\\n    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)\\n    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)\\n    ate (bool) asymmetric tautology elimination (default: true)\\n    auto_config (bool) automatically configure solver (default: true)\\n    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)\\n    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)\\n    bca (bool) blocked clause addition - add blocked binary clauses (default: false)\\n    bce (bool) eliminate blocked clauses (default: false)\\n    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)\\n    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_add (bool) bit-blast adders. (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_full (bool) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms. (default: false)\\n    blast_mul (bool) bit-blast multipliers (and dividers, remainders). (default: true)\\n    blast_quant (bool) bit-blast quantified variables. (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)\\n    bound_max_refinements (unsigned int) (default: 16) maximum number of bound refinements (per round) for unbounded variables.\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bound_threshold (double) (default: 0.05) bound propagation improvement threshold ratio.\\n    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)\\n    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)\\n    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    cardinality.encoding (symbol) encoding used for cardinality constraints: grouped, bimander, ordered, unate, circuit (default: none)\\n    cardinality.solver (bool) use cardinality solver (default: true)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    cce (bool) eliminate covered clauses (default: false)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    compile_equality (bool) (default:false) compile equalities into pseudo-Boolean equality\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    cut (bool) enable AIG based simplification in-processing (default: false)\\n    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)\\n    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)\\n    cut.dont_cares (bool) integrate dont cares with cuts (default: true)\\n    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)\\n    cut.lut (bool) extract luts from clauses for cut simplification (default: false)\\n    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)\\n    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)\\n    cut.xor (bool) extract xors from clauses for cut simplification (default: false)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)\\n    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)\\n    ddfw.restart_base (unsigned int) number of flips used a starting point for hesitant restart backoff (default: 100000)\\n    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)\\n    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)\\n    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)\\n    drat.activity (bool) dump variable activities (default: false)\\n    drat.binary (bool) use Binary DRAT output format (default: false)\\n    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)\\n    drat.check_unsat (bool) build up internal proof and check (default: false)\\n    drat.disable (bool) override anything that enables DRAT (default: false)\\n    drat.file (symbol) file to dump DRAT proofs (default: )\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    euf (bool) enable euf solver (this feature is preliminary and not ready for general consumption) (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)\\n    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)\\n    gc.burst (bool) perform eager garbage collection during initialization (default: false)\\n    gc.defrag (bool) defragment clauses when garbage collecting (default: true)\\n    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)\\n    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)\\n    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)\\n    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)\\n    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )\\n    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    keep_cardinality_constraints (bool) retain cardinality constraints (don't bit-blast them) and use built-in cardinality solver (default: false)\\n    learned (bool) (default: false) collect also learned clauses.\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    lia2pb_max_bits (unsigned int) (default: 32) maximum number of bits to be used (per variable) in lia2pb.\\n    lia2pb_partial (bool) (default: false) partial lia2pb conversion.\\n    lia2pb_total_bits (unsigned int) (default: 2048) total number of bits to be used (per problem) in lia2pb.\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    local_search (bool) use local search instead of CDCL (default: false)\\n    local_search_dbg_flips (bool) write debug information for number of flips (default: false)\\n    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)\\n    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)\\n    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)\\n    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)\\n    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)\\n    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)\\n    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)\\n    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)\\n    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)\\n    lookahead.double (bool) enable double lookahead (default: true)\\n    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)\\n    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)\\n    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)\\n    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)\\n    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)\\n    lookahead_simplify (bool) use lookahead solver during simplification (default: false)\\n    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_depth (unsigned int) maximum term depth. (default: 1024)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    minimize_lemmas (bool) minimize learned clauses (default: true)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    norm_int_only (bool) normalize only the bounds of integer constants. (default: true)\\n    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)\\n    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)\\n    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)\\n    pb.solver (symbol) encoding used for Pseudo-Boolean constraints: totalizer, sorting, binary_merge, bv, solver. PB constraints are retained if set to 'solver' (default: solver)\\n    pb2bv_all_clauses_limit (unsigned int) (default: 8) maximum number of literals for using equivalent CNF encoding of PB constraint.\\n    pb2bv_cardinality_limit (unsigned int) (default: inf) limit for using arc-consistent cardinality constraint encoding.\\n    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching, local_search (default: caching)\\n    phase.sticky (bool) use sticky phase caching (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    prob_search (bool) use probsat local search instead of CDCL (default: false)\\n    probing (bool) apply failed literal detection during simplification (default: true)\\n    probing_binary (bool) probe binary clauses (default: true)\\n    probing_cache (bool) add binary literals as lemmas (default: true)\\n    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)\\n    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)\\n    produce_models (bool) model generation. (default: false)\\n    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)\\n    propagate_eq (bool) enable equality propagation from bounds. (default: false)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_freq (double) frequency of random case splits (default: 0.01)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)\\n    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)\\n    reorder.itau (double) inverse temperature for softmax (default: 4.0)\\n    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)\\n    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)\\n    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)\\n    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)\\n    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)\\n    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)\\n    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)\\n    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)\\n    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)\\n    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)\\n    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)\\n    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)\\n    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)\\n    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)\\n    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)\\n    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)\\n    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)\\n    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)\\n    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)\\n    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)\\n    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    smt (bool) use the SAT solver based incremental SMT core (default: false)\\n    smt.proof.check (bool) check proofs on the fly during SMT search (default: false)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    subsumption (bool) eliminate subsumed clauses (default: true)\\n    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)\\n- qflra builtin strategy for solving QF_LRA problems.\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n- qfnia builtin strategy for solving QF_NIA problems.\\n    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)\\n    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    anf (bool) enable ANF based simplification in-processing (default: false)\\n    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)\\n    anf.exlin (bool) enable extended linear simplification (default: false)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    asymm_branch (bool) asymmetric branching (default: true)\\n    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)\\n    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)\\n    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)\\n    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)\\n    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)\\n    ate (bool) asymmetric tautology elimination (default: true)\\n    auto_config (bool) automatically configure solver (default: true)\\n    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)\\n    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)\\n    bca (bool) blocked clause addition - add blocked binary clauses (default: false)\\n    bce (bool) eliminate blocked clauses (default: false)\\n    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)\\n    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_add (bool) bit-blast adders. (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_full (bool) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms. (default: false)\\n    blast_mul (bool) bit-blast multipliers (and dividers, remainders). (default: true)\\n    blast_quant (bool) bit-blast quantified variables. (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)\\n    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)\\n    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    cardinality.encoding (symbol) encoding used for cardinality constraints: grouped, bimander, ordered, unate, circuit (default: none)\\n    cardinality.solver (bool) use cardinality solver (default: true)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    cce (bool) eliminate covered clauses (default: false)\\n    cell_sample (bool) cell sample projection (default: true)\\n    check_lemmas (bool) check lemmas on the fly using an independent nlsat solver (default: false)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    cofactor_equalities (bool) (default: true) use equalities to rewrite bodies of ite-expressions. This is potentially expensive.\\n    common_patterns (bool) minimize the number of auxiliary variables during CNF encoding by identifying commonly used patterns (default: true)\\n    compile_equality (bool) (default:false) compile equalities into pseudo-Boolean equality\\n    complete (bool) add constraints to make sure that any interpretation of a underspecified arithmetic operators is a function. The result will include additional uninterpreted functions/constants: /0, div0, mod0, 0^0, neg-root (default: true)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize computed core (default: false)\\n    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    cut (bool) enable AIG based simplification in-processing (default: false)\\n    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)\\n    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)\\n    cut.dont_cares (bool) integrate dont cares with cuts (default: true)\\n    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)\\n    cut.lut (bool) extract luts from clauses for cut simplification (default: false)\\n    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)\\n    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)\\n    cut.xor (bool) extract xors from clauses for cut simplification (default: false)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)\\n    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)\\n    ddfw.restart_base (unsigned int) number of flips used a starting point for hesitant restart backoff (default: 100000)\\n    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)\\n    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)\\n    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)\\n    distributivity (bool) minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas (default: true)\\n    distributivity_blowup (unsigned int) maximum overhead for applying distributivity during CNF encoding (default: 32)\\n    drat.activity (bool) dump variable activities (default: false)\\n    drat.binary (bool) use Binary DRAT output format (default: false)\\n    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)\\n    drat.check_unsat (bool) build up internal proof and check (default: false)\\n    drat.disable (bool) override anything that enables DRAT (default: false)\\n    drat.file (symbol) file to dump DRAT proofs (default: )\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_inverses (bool) eliminate inverse trigonometric functions (asin, acos, atan). (default: true)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_root_objects (bool) eliminate root objects. (default: true)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    euf (bool) enable euf solver (this feature is preliminary and not ready for general consumption) (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    factor (bool) (default: true) factor polynomials.\\n    factor_max_prime (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step (default: 31)\\n    factor_num_primes (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifting and searching (default: 1)\\n    factor_search_size (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space (default: 5000)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)\\n    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)\\n    gc.burst (bool) perform eager garbage collection during initialization (default: false)\\n    gc.defrag (bool) defragment clauses when garbage collecting (default: true)\\n    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)\\n    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)\\n    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)\\n    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    inline_vars (bool) inline variables that can be isolated from equations (not supported in incremental mode) (default: false)\\n    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)\\n    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )\\n    ite_chaing (bool) minimize the number of auxiliary variables during CNF encoding by identifying if-then-else chains (default: true)\\n    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    keep_cardinality_constraints (bool) retain cardinality constraints for solver (default: true)\\n    lazy (unsigned int) how lazy the solver is. (default: 0)\\n    learned (bool) (default: false) collect also learned clauses.\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    local_search (bool) use local search instead of CDCL (default: false)\\n    local_search_dbg_flips (bool) write debug information for number of flips (default: false)\\n    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)\\n    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)\\n    log_lemmas (bool) display lemmas as self-contained SMT formulas (default: false)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)\\n    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)\\n    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)\\n    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)\\n    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)\\n    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)\\n    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)\\n    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)\\n    lookahead.double (bool) enable double lookahead (default: true)\\n    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)\\n    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)\\n    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)\\n    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)\\n    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)\\n    lookahead_simplify (bool) use lookahead solver during simplification (default: false)\\n    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.\\n    max_conflicts (unsigned int) maximum number of conflicts (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_depth (unsigned int) maximum term depth. (default: 1024)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_prime (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step.\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_search_size (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space.\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    min_mag (unsigned int) Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16 (default: 16)\\n    minimize_conflicts (bool) minimize conflicts (default: false)\\n    minimize_lemmas (bool) minimize learned clauses (default: true)\\n    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    nla2bv_bv_size (unsigned int) default bit-vector size used by nla2bv tactic. (default: 4)\\n    nla2bv_divisor (unsigned int) nla2bv tactic parameter. (default: 2)\\n    nla2bv_max_bv_size (unsigned int) (default: inf) maximum bit-vector size used by nla2bv tactic\\n    nla2bv_root (unsigned int) nla2bv tactic encodes reals into bit-vectors using expressions of the form a+b*sqrt(c), this parameter sets the value of c used in the encoding. (default: 2)\\n    num_primes (unsigned int) (default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching.\\n    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)\\n    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)\\n    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)\\n    pb.solver (symbol) encoding used for Pseudo-Boolean constraints: totalizer, sorting, binary_merge, bv, solver. PB constraints are retained if set to 'solver' (default: solver)\\n    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching, local_search (default: caching)\\n    phase.sticky (bool) use sticky phase caching (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    prob_search (bool) use probsat local search instead of CDCL (default: false)\\n    probing (bool) apply failed literal detection during simplification (default: true)\\n    probing_binary (bool) probe binary clauses (default: true)\\n    probing_cache (bool) add binary literals as lemmas (default: true)\\n    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)\\n    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)\\n    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)\\n    propagate_eq (bool) enable equality propagation from bounds. (default: false)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_freq (double) frequency of random case splits (default: 0.01)\\n    random_seed (unsigned int) random seed (default: 0)\\n    randomize (bool) randomize selection of a witness in nlsat. (default: true)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    reorder (bool) reorder variables. (default: true)\\n    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)\\n    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)\\n    reorder.itau (double) inverse temperature for softmax (default: 4.0)\\n    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)\\n    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)\\n    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)\\n    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)\\n    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)\\n    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)\\n    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)\\n    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)\\n    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)\\n    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)\\n    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)\\n    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)\\n    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)\\n    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)\\n    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)\\n    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)\\n    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)\\n    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)\\n    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)\\n    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)\\n    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)\\n    seed (unsigned int) random seed. (default: 0)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    shuffle_vars (bool) use a random variable order. (default: false)\\n    simple_check (bool) precheck polynomials using variables sign (default: false)\\n    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)\\n    simplify_conflicts (bool) simplify conflicts using equalities before resolving them in nlsat solver. (default: true)\\n    sk_hack (bool) hack for VCC (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    smt (bool) use the SAT solver based incremental SMT core (default: false)\\n    smt.proof.check (bool) check proofs on the fly during SMT search (default: false)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    subsumption (bool) eliminate subsumed clauses (default: true)\\n    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) number of parallel threads to use (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)\\n    variable_ordering_strategy (unsigned int) Variable Ordering Strategy, 0 for none, 1 for BROWN, 2 for TRIANGULAR, 3 for ONLYPOLY (default: 0)\\n    zero_accuracy (unsigned int) one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k) (default: 0)\\n- qfnra builtin strategy for solving QF_NRA problems.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n- qfuf builtin strategy for solving QF_UF problems.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n- qfufbv builtin strategy for solving QF_UFBV problems.\\n    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)\\n    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    anf (bool) enable ANF based simplification in-processing (default: false)\\n    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)\\n    anf.exlin (bool) enable extended linear simplification (default: false)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    asymm_branch (bool) asymmetric branching (default: true)\\n    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)\\n    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)\\n    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)\\n    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)\\n    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)\\n    ate (bool) asymmetric tautology elimination (default: true)\\n    auto_config (bool) automatically configure solver (default: true)\\n    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)\\n    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)\\n    bca (bool) blocked clause addition - add blocked binary clauses (default: false)\\n    bce (bool) eliminate blocked clauses (default: false)\\n    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)\\n    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_add (bool) bit-blast adders. (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_full (bool) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms. (default: false)\\n    blast_mul (bool) bit-blast multipliers (and dividers, remainders). (default: true)\\n    blast_quant (bool) bit-blast quantified variables. (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)\\n    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)\\n    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)\\n    cardinality.solver (bool) use cardinality solver (default: true)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    cce (bool) eliminate covered clauses (default: false)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    cut (bool) enable AIG based simplification in-processing (default: false)\\n    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)\\n    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)\\n    cut.dont_cares (bool) integrate dont cares with cuts (default: true)\\n    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)\\n    cut.lut (bool) extract luts from clauses for cut simplification (default: false)\\n    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)\\n    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)\\n    cut.xor (bool) extract xors from clauses for cut simplification (default: false)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)\\n    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)\\n    ddfw.restart_base (unsigned int) number of flips used a starting point for hesitant restart backoff (default: 100000)\\n    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)\\n    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)\\n    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)\\n    div0_ackermann_limit (unsigned int) a bound for number of congruence Ackermann lemmas for div0 modelling (default: 1000)\\n    drat.activity (bool) dump variable activities (default: false)\\n    drat.binary (bool) use Binary DRAT output format (default: false)\\n    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)\\n    drat.check_unsat (bool) build up internal proof and check (default: false)\\n    drat.disable (bool) override anything that enables DRAT (default: false)\\n    drat.file (symbol) file to dump DRAT proofs (default: )\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    euf (bool) enable euf solver (this feature is preliminary and not ready for general consumption) (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)\\n    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)\\n    gc.burst (bool) perform eager garbage collection during initialization (default: false)\\n    gc.defrag (bool) defragment clauses when garbage collecting (default: true)\\n    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)\\n    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)\\n    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)\\n    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)\\n    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )\\n    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    learned (bool) (default: false) collect also learned clauses.\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    local_search (bool) use local search instead of CDCL (default: false)\\n    local_search_dbg_flips (bool) write debug information for number of flips (default: false)\\n    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)\\n    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)\\n    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)\\n    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)\\n    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)\\n    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)\\n    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)\\n    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)\\n    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)\\n    lookahead.double (bool) enable double lookahead (default: true)\\n    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)\\n    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)\\n    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)\\n    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)\\n    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)\\n    lookahead_simplify (bool) use lookahead solver during simplification (default: false)\\n    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    minimize_lemmas (bool) minimize learned clauses (default: true)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)\\n    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)\\n    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)\\n    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)\\n    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching, local_search (default: caching)\\n    phase.sticky (bool) use sticky phase caching (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    prob_search (bool) use probsat local search instead of CDCL (default: false)\\n    probing (bool) apply failed literal detection during simplification (default: true)\\n    probing_binary (bool) probe binary clauses (default: true)\\n    probing_cache (bool) add binary literals as lemmas (default: true)\\n    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)\\n    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)\\n    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_freq (double) frequency of random case splits (default: 0.01)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)\\n    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)\\n    reorder.itau (double) inverse temperature for softmax (default: 4.0)\\n    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)\\n    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)\\n    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)\\n    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)\\n    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)\\n    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)\\n    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)\\n    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)\\n    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)\\n    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)\\n    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)\\n    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)\\n    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)\\n    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)\\n    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)\\n    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)\\n    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)\\n    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)\\n    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)\\n    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)\\n    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    smt (bool) use the SAT solver based incremental SMT core (default: false)\\n    smt.proof.check (bool) check proofs on the fly during SMT search (default: false)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    subsumption (bool) eliminate subsumed clauses (default: true)\\n    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)\\n- qfufbv_ackr A tactic for solving QF_UFBV based on Ackermannization.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n- ufnia builtin strategy for solving UFNIA problems.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_depth (unsigned int) maximum term depth. (default: 1024)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    propagate_eq (bool) enable equality propagation from bounds. (default: false)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n- uflra builtin strategy for solving UFLRA problems.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_depth (unsigned int) maximum term depth. (default: 1024)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    propagate_eq (bool) enable equality propagation from bounds. (default: false)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n- auflia builtin strategy for solving AUFLIA problems.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_depth (unsigned int) maximum term depth. (default: 1024)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    propagate_eq (bool) enable equality propagation from bounds. (default: false)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n- auflira builtin strategy for solving AUFLIRA problems.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_depth (unsigned int) maximum term depth. (default: 1024)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    propagate_eq (bool) enable equality propagation from bounds. (default: false)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n- aufnira builtin strategy for solving AUFNIRA problems.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_depth (unsigned int) maximum term depth. (default: 1024)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    propagate_eq (bool) enable equality propagation from bounds. (default: false)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n- lra builtin strategy for solving LRA problems.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_depth (unsigned int) maximum term depth. (default: 1024)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    propagate_eq (bool) enable equality propagation from bounds. (default: false)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n- lia builtin strategy for solving LIA problems.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_depth (unsigned int) maximum term depth. (default: 1024)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    propagate_eq (bool) enable equality propagation from bounds. (default: false)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n- lira builtin strategy for solving LIRA problems.\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_depth (unsigned int) maximum term depth. (default: 1024)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    propagate_eq (bool) enable equality propagation from bounds. (default: false)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n- smt apply a SAT based SMT solver.\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n- skip do nothing tactic.\\n- fail always fail tactic.\\n- fail-if-undecided fail if goal is undecided.\\n- macro-finder Identifies and applies macros.\\n    elim_and (bool) (default: false) eliminate conjunctions during (internal) calls to the simplifier.\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    produce_models (bool) model generation. (default: false)\\n    produce_proofs (bool) proof generation. (default: false)\\n- quasi-macros Identifies and applies quasi-macros.\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    produce_models (bool) model generation. (default: false)\\n    produce_proofs (bool) proof generation. (default: false)\\n- ufbv-rewriter Applies UFBV-specific rewriting rules, mainly demodulation.\\n    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes. (default: 4294967295)\\n    produce_models (bool) model generation. (default: false)\\n    produce_proofs (bool) proof generation. (default: false)\\n- bv builtin strategy for solving BV problems (with quantifiers).\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    produce_models (bool) model generation. (default: false)\\n    produce_proofs (bool) proof generation. (default: false)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    sk_hack (bool) hack for VCC (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\n- ufbv builtin strategy for solving UFBV problems (with quantifiers).\\n    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)\\n    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)\\n    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)\\n    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)\\n    arith.dump_bound_lemmas (bool) dump linear solver bounds to files in smt2 format (default: false)\\n    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)\\n    arith.eager_eq_axioms (bool) eager equality axioms (default: true)\\n    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)\\n    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)\\n    arith.ignore_int (bool) treat integer variables as real (default: false)\\n    arith.int_eq_branch (bool) branching using derived integer equations (default: false)\\n    arith.min (bool) minimize cost (default: false)\\n    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)\\n    arith.nl.branching (bool) branching on integer variables in non linear clusters (default: true)\\n    arith.nl.cross_nested (bool) enable cross-nested consistency checking (default: true)\\n    arith.nl.delay (unsigned int) number of calls to final check before invoking bounded nlsat check (default: 10)\\n    arith.nl.expensive_patching (bool) use the expensive of monomials (default: false)\\n    arith.nl.expp (bool) expensive patching (default: false)\\n    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)\\n    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)\\n    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)\\n    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)\\n    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)\\n    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)\\n    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)\\n    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)\\n    arith.nl.grobner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 1)\\n    arith.nl.horner (bool) run horner's heuristic (default: true)\\n    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)\\n    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)\\n    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)\\n    arith.nl.log (bool) Log lemmas sent to nra solver (default: false)\\n    arith.nl.nra (bool) call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)\\n    arith.nl.optimize_bounds (bool) enable bounds optimization (default: true)\\n    arith.nl.order (bool) run order lemmas (default: true)\\n    arith.nl.propagate_linear_monomials (bool) propagate linear monomials (default: true)\\n    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)\\n    arith.nl.tangents (bool) run tangent lemmas (default: true)\\n    arith.print_ext_var_names (bool) print external variable names (default: false)\\n    arith.print_stats (bool) print statistic (default: false)\\n    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)\\n    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds (default: 1)\\n    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)\\n    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)\\n    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)\\n    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)\\n    arith.validate (bool) validate lemmas generated by arithmetic solver (default: false)\\n    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)\\n    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)\\n    array.extensional (bool) extensional array theory (default: true)\\n    array.weak (bool) weak array theory (default: false)\\n    auto_config (bool) automatically configure solver (default: true)\\n    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)\\n    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)\\n    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)\\n    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)\\n    blast_select_store (bool) eagerly replace all (select (store ..) ..) term by an if-then-else term (default: false)\\n    bound_simplifier (bool) apply bounds simplification during pre-processing (default: true)\\n    bv.delay (bool) delay internalize expensive bit-vector operations (default: false)\\n    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)\\n    bv.reflect (bool) create enode for every bit-vector term (default: true)\\n    bv.size_reduce (bool) pre-processing; turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant (default: false)\\n    bv.solver (unsigned int) bit-vector solver engine: 0 - bit-blasting, 1 - polysat, 2 - intblast, requires sat.smt=true (default: 0)\\n    bv.watch_diseq (bool) use watch lists instead of eager axioms for bit-vectors (default: false)\\n    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)\\n    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)\\n    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)\\n    bv_le2extract (bool) disassemble bvule to extract (default: true)\\n    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)\\n    bv_not_simpl (bool) apply simplifications for bvnot (default: false)\\n    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)\\n    cache_all (bool) cache all intermediate results. (default: false)\\n    candidate_models (bool) create candidate models even when quantifier or theory reasoning is incomplete (default: false)\\n    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)\\n    clause_proof (bool) record a clausal proof (default: false)\\n    context_solve (bool) solve equalities under disjunctions. (default: false)\\n    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)\\n    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)\\n    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)\\n    core.minimize (bool) minimize unsat core produced by SMT context (default: false)\\n    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)\\n    cube_depth (unsigned int) cube depth. (default: 1)\\n    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)\\n    dack.eq (bool) enable dynamic ackermannization for transitivity of equalities (default: false)\\n    dack.factor (double) number of instance per conflict (default: 0.1)\\n    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)\\n    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)\\n    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)\\n    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)\\n    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)\\n    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)\\n    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)\\n    elim_ite (bool) eliminate ite in favor of and/or (default: true)\\n    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)\\n    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)\\n    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)\\n    elim_unconstrained (bool) pre-processing: eliminate unconstrained subterms (default: true)\\n    eliminate_mod (bool) eliminate modulus from equations (default: true)\\n    ematching (bool) E-Matching based quantifier instantiation (default: true)\\n    enable_der (bool) enable destructive equality resolution to quantifiers. (default: true)\\n    eq2ineq (bool) expand equalities into two inequalities (default: false)\\n    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)\\n    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)\\n    expand_select_ite (bool) expand select over ite expressions (default: false)\\n    expand_select_store (bool) conservatively replace a (select (store ...) ...) term by an if-then-else term (default: false)\\n    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)\\n    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)\\n    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.\\n    flat (bool) create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)\\n    flat_and_or (bool) create nary applications for and,or (default: true)\\n    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)\\n    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)\\n    hoist_ite (bool) hoist shared summands under ite expressions (default: false)\\n    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)\\n    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)\\n    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)\\n    induction (bool) enable generation of induction lemmas (default: false)\\n    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: true)\\n    ite_solver (bool) use if-then-else solver. (default: true)\\n    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)\\n    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)\\n    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)\\n    logic (symbol) logic used to setup the SMT solver (default: )\\n    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)\\n    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)\\n    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)\\n    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)\\n    max_rounds (unsigned int) maximum number of rounds. (default: 4)\\n    max_steps (unsigned int) maximum number of steps (default: 4294967295)\\n    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)\\n    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)\\n    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )\\n    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)\\n    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)\\n    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)\\n    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)\\n    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)\\n    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)\\n    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)\\n    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)\\n    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)\\n    phase_caching_off (unsigned int) number of conflicts while phase caching is off (default: 100)\\n    phase_caching_on (unsigned int) number of conflicts while phase caching is on (default: 400)\\n    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)\\n    produce_models (bool) model generation. (default: false)\\n    produce_proofs (bool) proof generation. (default: false)\\n    propagate_values (bool) pre-processing: propagate values (default: true)\\n    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)\\n    pull_nested_quantifiers (bool) pre-processing: pull nested quantifiers (default: false)\\n    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)\\n    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)\\n    push_to_real (bool) distribute to_real over * and +. (default: true)\\n    q.lift_ite (unsigned int) 0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers (default: 0)\\n    q.lite (bool) Use cheap quantifier elimination during pre-processing (default: false)\\n    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))\\n    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)\\n    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)\\n    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)\\n    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)\\n    qi.profile (bool) profile quantifier instantiation (default: false)\\n    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)\\n    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)\\n    qsat_use_qel (bool) Use QEL for lite quantifier elimination and model-based projection in QSAT (default: true)\\n    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)\\n    random_seed (unsigned int) random seed for the smt solver (default: 0)\\n    refine_inj_axioms (bool) pre-processing: refine injectivity axioms (default: true)\\n    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)\\n    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)\\n    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)\\n    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)\\n    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)\\n    rewrite_patterns (bool) rewrite patterns. (default: false)\\n    seq.max_unfolding (unsigned int) maximal unfolding depth for checking string equations and regular expressions (default: 1000000000)\\n    seq.min_unfolding (unsigned int) initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths (default: 1)\\n    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)\\n    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)\\n    sk_hack (bool) hack for VCC (default: false)\\n    sls.enable (bool) enable sls co-processor with SMT engine (default: false)\\n    sls.parallel (bool) use sls co-processor in parallel or sequential with SMT engine (default: true)\\n    solve_eqs (bool) pre-processing: solve equalities (default: true)\\n    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations. (default: 4294967295)\\n    som (bool) put polynomials in sum-of-monomials form (default: false)\\n    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)\\n    sort_disjunctions (bool) sort subterms in disjunctions (default: true)\\n    sort_store (bool) sort nested stores when the indices are known to be different (default: false)\\n    sort_sums (bool) sort the arguments of + application. (default: false)\\n    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)\\n    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)\\n    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)\\n    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)\\n    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)\\n    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)\\n    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)\\n    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)\\n    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)\\n    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)\\n    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)\\n    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)\\n    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)\\n    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)\\n    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)\\n    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)\\n    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)\\n    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)\\n    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)\\n    theory_solver (bool) theory solvers. (default: true)\\n    threads (unsigned int) maximal number of parallel threads. (default: 1)\\n    threads.cube_frequency (unsigned int) frequency for using cubing (default: 2)\\n    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)\\n    up.persist_clauses (bool) replay propagated clauses below the levels they are asserted (default: false)\\nbuiltin probes:\\n- ackr-bound-probe A probe to give an upper bound of Ackermann congruence lemmas that a formula might generate.\\n- is-unbounded true if the goal contains integer/real constants that do not have lower/upper bounds.\\n- is-pb true if the goal is a pseudo-boolean problem.\\n- arith-max-deg max polynomial total degree of an arithmetic atom.\\n- arith-avg-deg avg polynomial total degree of an arithmetic atom.\\n- arith-max-bw max coefficient bit width.\\n- arith-avg-bw avg coefficient bit width.\\n- is-qflia true if the goal is in QF_LIA.\\n- is-qfauflia true if the goal is in QF_AUFLIA.\\n- is-qflra true if the goal is in QF_LRA.\\n- is-qflira true if the goal is in QF_LIRA.\\n- is-ilp true if the goal is ILP.\\n- is-qfnia true if the goal is in QF_NIA (quantifier-free nonlinear integer arithmetic).\\n- is-qfnra true if the goal is in QF_NRA (quantifier-free nonlinear real arithmetic).\\n- is-nia true if the goal is in NIA (nonlinear integer arithmetic, formula may have quantifiers).\\n- is-nra true if the goal is in NRA (nonlinear real arithmetic, formula may have quantifiers).\\n- is-nira true if the goal is in NIRA (nonlinear integer and real arithmetic, formula may have quantifiers).\\n- is-lia true if the goal is in LIA (linear integer arithmetic, formula may have quantifiers).\\n- is-lra true if the goal is in LRA (linear real arithmetic, formula may have quantifiers).\\n- is-lira true if the goal is in LIRA (linear integer and real arithmetic, formula may have quantifiers).\\n- is-qfufnra true if the goal is QF_UFNRA (quantifier-free nonlinear real arithmetic with other theories).\\n- is-qfbv-eq true if the goal is in a fragment of QF_BV which uses only =, extract, concat.\\n- is-qffp true if the goal is in QF_FP (floats).\\n- is-qffpbv true if the goal is in QF_FPBV (floats+bit-vectors).\\n- is-qffplra true if the goal is in QF_FPLRA.\\n- memory amount of used memory in megabytes.\\n- depth depth of the input goal.\\n- size number of assertions in the given goal.\\n- num-exprs number of expressions/terms in the given goal.\\n- num-consts number of non Boolean constants in the given goal.\\n- num-bool-consts number of Boolean constants in the given goal.\\n- num-arith-consts number of arithmetic constants in the given goal.\\n- num-bv-consts number of bit-vector constants in the given goal.\\n- produce-proofs true if proof generation is enabled for the given goal.\\n- produce-model true if model generation is enabled for the given goal.\\n- produce-unsat-cores true if unsat-core generation is enabled for the given goal.\\n- has-quantifiers true if the goal contains quantifiers.\\n- has-patterns true if the goal contains quantifiers with patterns.\\n- is-propositional true if the goal is in propositional logic.\\n- is-qfbv true if the goal is in QF_BV.\\n- is-qfaufbv true if the goal is in QF_AUFBV.\\n- is-quasi-pb true if the goal is quasi-pb.\\n\\\"\\n\",\"error\":\"\",\"status\":\"z3-ran\",\"hash\":\"fe60234edfb2ce11cea754a552461f4302ba81b0\"},\"githubRepo\":\"Z3Prover/z3\",\"editable\":false,\"readonly\":false,\"showLineNumbers\":true,\"langVersion\":\"4.15.1\",\"tool\":\"z3-solver\"}"}),"\n",(0,i.jsx)(t.p,{children:"Z3 comes equipped with the following tactic combinators (aka tacticals):"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"(then t s)"})," applies /t to the input goal and /s to every subgoal produced by /t."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"(par-then t s)"})," applies /t to the input goal and /s to every subgoal produced by /t in parallel."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"(or-else t s)"})," first applies /t to the given goal, if it fails then returns the result of /s applied to the given goal."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"(par-or t s)"})," applies /t and /s in parallel until one of them succeed. The tactic fails if /t and /s fails."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"(repeat t)"})," Keep applying the given tactic until no subgoal is modified by it."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"(repeat t n)"})," Keep applying the given tactic until no subgoal is modified by it, or the number of iterations is greater than /n."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"(try-for t ms)"})," Apply tactic /t to the input goal, if it does not return in /ms milliseconds, it fails."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"(using-params t params)"})," Apply the given tactic using the given parameters. ",(0,i.jsx)(t.code,{children:"(! t params)"})," is a shorthand for ",(0,i.jsx)(t.code,{children:"(using-params t params)"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The combinators ",(0,i.jsx)(t.code,{children:"then"}),", ",(0,i.jsx)(t.code,{children:"par-then"}),", ",(0,i.jsx)(t.code,{children:"or-else"})," and ",(0,i.jsx)(t.code,{children:"par-or"})," accept arbitrary number of arguments. The following example demonstrate how to use these combinators."]}),"\n",(0,i.jsx)(l.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const x Real)\\n(declare-const y Real)\\n(declare-const z Real)\\n\\n(assert (or (= x 0.0) (= x 1.0)))\\n(assert (or (= y 0.0) (= y 1.0)))\\n(assert (or (= z 0.0) (= z 1.0)))\\n(assert (> (+ x y z) 2.0))\\n\\n(echo \\"split all...\\")\\n(apply (repeat (or-else split-clause skip)))\\n\\n(echo \\"split at most 2...\\")\\n(apply (repeat (or-else split-clause skip) 1))\\n\\n(echo \\"split and solve-eqs...\\")\\n(apply (then (repeat (or-else split-clause skip)) solve-eqs))","result":{"output":"split all...\\n(goals\\n(goal\\n  (= x 0.0)\\n  (= y 0.0)\\n  (= z 0.0)\\n  (> (+ x y z) 2.0)\\n  :precision precise :depth 3)\\n(goal\\n  (= x 0.0)\\n  (= y 0.0)\\n  (= z 1.0)\\n  (> (+ x y z) 2.0)\\n  :precision precise :depth 3)\\n(goal\\n  (= x 0.0)\\n  (= y 1.0)\\n  (= z 0.0)\\n  (> (+ x y z) 2.0)\\n  :precision precise :depth 3)\\n(goal\\n  (= x 0.0)\\n  (= y 1.0)\\n  (= z 1.0)\\n  (> (+ x y z) 2.0)\\n  :precision precise :depth 3)\\n(goal\\n  (= x 1.0)\\n  (= y 0.0)\\n  (= z 0.0)\\n  (> (+ x y z) 2.0)\\n  :precision precise :depth 3)\\n(goal\\n  (= x 1.0)\\n  (= y 0.0)\\n  (= z 1.0)\\n  (> (+ x y z) 2.0)\\n  :precision precise :depth 3)\\n(goal\\n  (= x 1.0)\\n  (= y 1.0)\\n  (= z 0.0)\\n  (> (+ x y z) 2.0)\\n  :precision precise :depth 3)\\n(goal\\n  (= x 1.0)\\n  (= y 1.0)\\n  (= z 1.0)\\n  (> (+ x y z) 2.0)\\n  :precision precise :depth 3)\\n)\\nsplit at most 2...\\n(goals\\n(goal\\n  (= x 0.0)\\n  (= y 0.0)\\n  (or (= z 0.0) (= z 1.0))\\n  (> (+ x y z) 2.0)\\n  :precision precise :depth 2)\\n(goal\\n  (= x 0.0)\\n  (= y 1.0)\\n  (or (= z 0.0) (= z 1.0))\\n  (> (+ x y z) 2.0)\\n  :precision precise :depth 2)\\n(goal\\n  (= x 1.0)\\n  (= y 0.0)\\n  (or (= z 0.0) (= z 1.0))\\n  (> (+ x y z) 2.0)\\n  :precision precise :depth 2)\\n(goal\\n  (= x 1.0)\\n  (= y 1.0)\\n  (or (= z 0.0) (= z 1.0))\\n  (> (+ x y z) 2.0)\\n  :precision precise :depth 2)\\n)\\nsplit and solve-eqs...\\n(goals\\n(goal\\n  :precision precise :depth 4)\\n)\\n","error":"","status":"z3-ran","hash":"143ca8d62ab46940307f4b1d53e02ffe94cd92d0"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,i.jsxs)(t.p,{children:["In the last apply command, the tactic ",(0,i.jsx)(t.code,{children:"solve-eqs"})," discharges all but one goal. Note that, this tactic generates one goal: the empty goal which is trivially satisfiable (i.e., feasible)"]}),"\n",(0,i.jsxs)(t.p,{children:["A tactic can be used to decide whether a set of assertions has a solution (i.e., is satisfiable) or not. The command ",(0,i.jsx)(t.code,{children:"check-sat-using"})," is similar to ",(0,i.jsx)(t.code,{children:"check-sat"}),", but uses the given tactic instead of the Z3 default solver for solving the current set of assertions. If the tactic produces the empty goal, then check-sat-using returns sat. If the tactic produces a single goal containing ",(0,i.jsx)(t.code,{children:"False"}),", then ",(0,i.jsx)(t.code,{children:"check-sat-using"})," returns ",(0,i.jsx)(t.code,{children:"unsat"}),". Otherwise, it returns ",(0,i.jsx)(t.code,{children:"unknown"}),"."]}),"\n",(0,i.jsx)(l.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const x (_ BitVec 16))\\n(declare-const y (_ BitVec 16))\\n\\n(assert (= (bvor x y) (_ bv13 16)))\\n(assert (bvslt x y))\\n\\n(check-sat-using (then simplify solve-eqs bit-blast sat))\\n(get-model)","result":{"output":"sat\\n(\\n  (define-fun y () (_ BitVec 16)\\n    #x000d)\\n  (define-fun x () (_ BitVec 16)\\n    #x0004)\\n)\\n","error":"","status":"z3-ran","hash":"7fddeceac54b33f3370fe9c2af7fb1731a7166da"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,i.jsx)(t.p,{children:"In the example above, the tactic used implements a basic bit-vector solver using equation solving, bit-blasting, and a propositional SAT solver."}),"\n",(0,i.jsxs)(t.p,{children:["In the following example, we use the combinator using-params to configure our little solver. We also include the tactic ",(0,i.jsx)(t.code,{children:"aig"})," which tries to compress Boolean formulas using And-Inverted Graphs."]}),"\n",(0,i.jsx)(l.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const x (_ BitVec 16))\\n(declare-const y (_ BitVec 16))\\n\\n(assert (= (bvadd (bvmul (_ bv32 16) x) y) (_ bv13 16)))\\n(assert (bvslt (bvand x y) (_ bv10 16)))\\n(assert (bvsgt y (bvneg (_ bv100 16))))\\n\\n(check-sat-using (then (using-params simplify :mul2concat true)\\n                       solve-eqs \\n                       bit-blast \\n                       aig\\n                       sat))\\n(get-model)\\n(get-value ((bvand x y)))","result":{"output":"sat\\n(\\n  (define-fun x () (_ BitVec 16)\\n    #x0500)\\n  (define-fun y () (_ BitVec 16)\\n    #x600d)\\n)\\n(((bvand x y) #x0000))\\n","error":"","status":"z3-ran","hash":"1194b6fb089052dceffd664d69c9feecae0db662"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,i.jsxs)(t.p,{children:["The tactic ",(0,i.jsx)(t.code,{children:"smt"})," wraps the main solver in Z3 as a tactic:"]}),"\n",(0,i.jsx)(l.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const x Int)\\n(declare-const y Int)\\n\\n(assert (> x (+ y 1)))\\n\\n(check-sat-using smt)\\n(get-model)","result":{"output":"sat\\n(\\n  (define-fun x () Int\\n    0)\\n  (define-fun y () Int\\n    (- 2))\\n)\\n","error":"","status":"z3-ran","hash":"5fea234f3beab0f710dc229b3df8d65f82f30195"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,i.jsx)(t.p,{children:"We now show how to implement a solver for integer arithmetic using SAT. The solver is complete only for problems where every variable has a lower and upper bound:"}),"\n",(0,i.jsx)(l.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const x Int)\\n(declare-const y Int)\\n(declare-const z Int)\\n\\n(assert (and (> x 0) (< x 10)))\\n(assert (and (> y 0) (< y 10)))\\n(assert (and (> z 0) (< z 10)))\\n(assert (= (+ (* 3 y) (* 2 x)) z))\\n\\n(check-sat-using (then (using-params simplify :arith-lhs true :som true)\\n                       normalize-bounds\\n                       lia2pb\\n                       pb2bv\\n                       bit-blast\\n                       sat))\\n(get-model)\\n\\n(reset)\\n\\n(declare-const x Int)\\n(declare-const y Int)\\n(declare-const z Int)\\n\\n(assert (= (+ (* 3 y) (* 2 x)) z))\\n\\n;; The next command will fail since x, y and z are not bounded.\\n(check-sat-using (then (using-params simplify :arith-lhs true :som true)\\n                       normalize-bounds\\n                       lia2pb\\n                       pb2bv\\n                       bit-blast\\n                       sat))\\n(get-info :reason-unknown)","result":{"output":"sat\\n(\\n  (define-fun x () Int\\n    2)\\n  (define-fun z () Int\\n    7)\\n  (define-fun y () Int\\n    1)\\n)\\nunknown\\n(:reason-unknown \\"goal is in a fragment not supported by pb2bv. Offending expression: y\\")\\n","error":"","status":"z3-ran","hash":"1159cf804b06270bfab29fdb4c29419b2fb62f47"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(f,{...e})}):f(e)}}}]);