"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2760],{8985(e,o,n){n.r(o),n.d(o,{assets:()=>d,contentTitle:()=>l,default:()=>f,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"logic/propositional-logic","title":"Propositional Logic","description":"The pre-defined sort Bool is the sort (type) of all Boolean propositional expressions. Z3 supports the usual Boolean operators and, or, xor, not, => (implication), ite (if-then-else). Bi-implications are represented using equality =. The following example shows how to prove that if p implies q and q implies r, then p implies r. We accomplish that by showing that the negation is unsatisfiable. The command define-fun is used to define a macro (aka alias). In this example, conjecture is an alias for the conjecture we want to prove.","source":"@site/docs-smtlib/01 - logic/03 - propositional-logic.md","sourceDirName":"01 - logic","slug":"/logic/propositional-logic","permalink":"/z3guide/docs/logic/propositional-logic","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/01 - logic/03 - propositional-logic.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Propositional Logic","sidebar_position":3},"sidebar":"smtlibSidebar","previous":{"title":"Basic Commands","permalink":"/z3guide/docs/logic/basiccommands"},"next":{"title":"Uninterpreted Functions and Constants","permalink":"/z3guide/docs/logic/Uninterpreted-functions-and-constants"}}');var s=n(4848),a=n(8453),r=n(6851);const i={title:"Propositional Logic",sidebar_position:3},l=void 0,d={},c=[{value:"Satisfiability and Validity",id:"satisfiability-and-validity",level:3},{value:"Cardinality Constraints",id:"cardinality-constraints",level:2},{value:"Pseudo Boolean Constraints",id:"pseudo-boolean-constraints",level:2},{value:"Unsatisfiable cores",id:"unsatisfiable-cores",level:2}];function u(e){const o={code:"code",em:"em",h2:"h2",h3:"h3",p:"p",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o.p,{children:"The pre-defined sort Bool is the sort (type) of all Boolean propositional expressions. Z3 supports the usual Boolean operators and, or, xor, not, => (implication), ite (if-then-else). Bi-implications are represented using equality =. The following example shows how to prove that if p implies q and q implies r, then p implies r. We accomplish that by showing that the negation is unsatisfiable. The command define-fun is used to define a macro (aka alias). In this example, conjecture is an alias for the conjecture we want to prove."}),"\n",(0,s.jsx)(r.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const p Bool)\\n(declare-const q Bool)\\n(declare-const r Bool)\\n(define-fun conjecture () Bool\\n\\t(=> (and (=> p q) (=> q r))\\n\\t\\t(=> p r)))\\n(assert (not conjecture))\\n(check-sat)","result":{"output":"unsat\\n","error":"","status":"z3-ran","hash":"f68e97a9fcabd10d58c1aae9c7f6a84b43ff74db"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,s.jsx)(o.h3,{id:"satisfiability-and-validity",children:"Satisfiability and Validity"}),"\n",(0,s.jsx)(o.p,{children:"A formula F is valid if F always evaluates to true for any assignment of appropriate values to its uninterpreted function and constant symbols. A formula F is satisfiable if there is some assignment of appropriate values to its uninterpreted function and constant symbols under which F evaluates to true. Validity is about finding a proof of a statement; satisfiability is about finding a solution to a set of constraints. Consider a formula F with some uninterpreted constants, say a and b. We can ask whether F is valid, that is whether it is always true for any combination of values for a and b. If F is always true, then not F is always false, and then not F will not have any satisfying assignment; that is, not F is unsatisfiable. That is, F is valid precisely when not F is not satisfiable (is unsatisfiable). Alternately, F is satisfiable if and only if not F is not valid (is invalid). Z3 finds satisfying assignments (or report that there are none). To determine whether a formula F is valid, we ask Z3 whether not F is satisfiable. Thus, to check the deMorgan's law is valid (i.e., to prove it), we show its negation to be unsatisfiable."}),"\n",(0,s.jsx)(r.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const a Bool)\\n(declare-const b Bool)\\n(define-fun demorgan () Bool\\n    (= (and a b) (not (or (not a) (not b)))))\\n(assert (not demorgan))\\n(check-sat)","result":{"output":"unsat\\n","error":"","status":"z3-ran","hash":"c5898a73fcc0781737aa788751bb4d35ab6fb4c8"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,s.jsx)(o.h2,{id:"cardinality-constraints",children:"Cardinality Constraints"}),"\n",(0,s.jsxs)(o.p,{children:["Logical disjunction ",(0,s.jsx)(o.code,{children:"(or p q r)"})," is true when at least one of the arguments ",(0,s.jsx)(o.code,{children:"p"}),", ",(0,s.jsx)(o.code,{children:"q"}),", ",(0,s.jsx)(o.code,{children:"r"})," is true. If you want to express that at least two of the arguments hold, then\nit is possible to encode using formulas such as ",(0,s.jsx)(o.code,{children:"(or (and p q) (and p r) (and q r))"}),". However, you can also express the constraint directly using a ",(0,s.jsx)(o.em,{children:"cardinality"})," constraint."]}),"\n",(0,s.jsx)(r.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const p Bool)\\n(declare-const q Bool)\\n(declare-const r Bool)\\n(assert ((_ at-least 2) p q r))\\n(check-sat)\\n(get-model)","result":{"output":"sat\\n(\\n  (define-fun p () Bool\\n    true)\\n  (define-fun q () Bool\\n    true)\\n  (define-fun r () Bool\\n    false)\\n)\\n","error":"","status":"z3-ran","hash":"0dd8b38d522410b0f3f8ca4fe3b807de741a1deb"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,s.jsx)(o.p,{children:"Dually, if at most one of the arguments should be true, you can express it as"}),"\n",(0,s.jsx)(r.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const p Bool)\\n(declare-const q Bool)\\n(declare-const r Bool)\\n(assert ((_ at-most 1) p q r))\\n(check-sat)\\n(get-model)","result":{"output":"sat\\n(\\n  (define-fun p () Bool\\n    false)\\n  (define-fun q () Bool\\n    false)\\n  (define-fun r () Bool\\n    true)\\n)\\n","error":"","status":"z3-ran","hash":"9ef16835af29f3a38f0783e1525fa11175865923"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,s.jsx)(o.h2,{id:"pseudo-boolean-constraints",children:"Pseudo Boolean Constraints"}),"\n",(0,s.jsx)(o.p,{children:"A generalization of cardinality constraints are Pseudo-Boolean formulas where\nthe sum of Boolean variables with coefficients are bounded."}),"\n",(0,s.jsxs)(o.p,{children:["The sum ",(0,s.jsx)(o.code,{children:"2p + q + 3r + 3s + 2t"})," as at least ",(0,s.jsx)(o.code,{children:"4"}),"."]}),"\n",(0,s.jsx)(r.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const p Bool)\\n(declare-const q Bool)\\n(declare-const r Bool)\\n(declare-const s Bool)\\n(declare-const t Bool)\\n(assert ((_ pbge 4 2 1 3 3 2) p q r s t))\\n(check-sat)\\n(get-model)","result":{"output":"sat\\n(\\n  (define-fun p () Bool\\n    true)\\n  (define-fun q () Bool\\n    false)\\n  (define-fun s () Bool\\n    false)\\n  (define-fun t () Bool\\n    false)\\n  (define-fun r () Bool\\n    true)\\n)\\n","error":"","status":"z3-ran","hash":"7923d2178a2cfc7afdd5ffdfcad01ba442d3d20c"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,s.jsxs)(o.p,{children:["The sum ",(0,s.jsx)(o.code,{children:"2p + q + 3r + 3s + 2t"})," as at most ",(0,s.jsx)(o.code,{children:"5"}),"."]}),"\n",(0,s.jsx)(r.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const p Bool)\\n(declare-const q Bool)\\n(declare-const r Bool)\\n(declare-const s Bool)\\n(declare-const t Bool)\\n(assert ((_ pble 5 2 1 3 3 2) p q r s t))\\n(check-sat)\\n(get-model)","result":{"output":"sat\\n(\\n  (define-fun p () Bool\\n    false)\\n  (define-fun q () Bool\\n    false)\\n  (define-fun r () Bool\\n    false)\\n  (define-fun s () Bool\\n    true)\\n  (define-fun t () Bool\\n    true)\\n)\\n","error":"","status":"z3-ran","hash":"2bf4908786e2697260d4fb150d4b71b06a5bf7db"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,s.jsxs)(o.p,{children:["The sum ",(0,s.jsx)(o.code,{children:"2p + q + 3r + 3s + 2t"})," equals ",(0,s.jsx)(o.code,{children:"5"}),"."]}),"\n",(0,s.jsx)(r.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const p Bool)\\n(declare-const q Bool)\\n(declare-const r Bool)\\n(declare-const s Bool)\\n(declare-const t Bool)\\n(assert ((_ pbeq 5 2 1 3 3 2) p q r s t))\\n(check-sat)\\n(get-model)","result":{"output":"sat\\n(\\n  (define-fun p () Bool\\n    true)\\n  (define-fun q () Bool\\n    false)\\n  (define-fun s () Bool\\n    false)\\n  (define-fun t () Bool\\n    false)\\n  (define-fun r () Bool\\n    true)\\n)\\n","error":"","status":"z3-ran","hash":"3a379fd9ad632a3c1f073e06397eaf99c2ed7b9d"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,s.jsx)(o.p,{children:"Cardinality, and Pseudo-Boolean, constraints can be\nmuch more succinct than CNF versions. Can you guess the secret\nformula? Hint: you can block clauses one by one for models\nof your failed guess, and see if you can find a pattern by counting\nthe number of variables that are true and false."}),"\n",(0,s.jsx)(r.A,{input:'{"lang":"z3-duo","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const a0 Bool)\\n(declare-const a1 Bool)\\n(declare-const a2 Bool)\\n(declare-const a3 Bool)\\n(declare-const a4 Bool)\\n(declare-const a5 Bool)","result":{"output":"(declare-const a0 Bool)\\n(declare-const a1 Bool)\\n(declare-const a2 Bool)\\n(declare-const a3 Bool)\\n(declare-const a4 Bool)\\n(declare-const a5 Bool)\\n(assert ((_ pbeq 3 1 1 1 1 1 1) a0 a1 a2 a3 a4 a5))"},"githubRepo":"Z3Prover/z3","editable":true,"readonly":false,"showLineNumbers":true}'}),"\n",(0,s.jsx)(o.h2,{id:"unsatisfiable-cores",children:"Unsatisfiable cores"}),"\n",(0,s.jsxs)(o.p,{children:["You can created ",(0,s.jsx)(o.em,{children:"named"})," assertions that are tracked when unsatisfiable core extraction is enabled. The unsatisfiable core is returned as a subset of named assertions that cannot be satisfied."]}),"\n",(0,s.jsx)(r.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(set-option :produce-unsat-cores true)\\n(declare-const p Bool)\\n(declare-const q Bool)\\n(declare-const r Bool)\\n(declare-const s Bool)\\n(declare-const t Bool)\\n(assert (! p :named +p))\\n(assert (! q :named +q))\\n(assert (! r :named +r))\\n(assert (! (not (or p q)) :named -p-or-q))\\n(check-sat)\\n(get-unsat-core)","result":{"output":"unsat\\n(+q -p-or-q)\\n","error":"","status":"z3-ran","hash":"8b9705ac48d9641e8cdecedf2e1bfcf2dfb08e4d"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'})]})}function f(e={}){const{wrapper:o}={...(0,a.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);