"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3455],{5953(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>f,frontMatter:()=>o,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"logic/Uninterpreted-functions-and-constants","title":"Uninterpreted Functions and Constants","description":"The basic building blocks of SMT formulas are constants and functions. Constants are just functions that take no arguments. So everything is really just a function.","source":"@site/docs-smtlib/01 - logic/04 - Uninterpreted-functions-and-constants.md","sourceDirName":"01 - logic","slug":"/logic/Uninterpreted-functions-and-constants","permalink":"/z3guide/docs/logic/Uninterpreted-functions-and-constants","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/01 - logic/04 - Uninterpreted-functions-and-constants.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Uninterpreted Functions and Constants","sidebar_position":4},"sidebar":"smtlibSidebar","previous":{"title":"Propositional Logic","permalink":"/z3guide/docs/logic/propositional-logic"},"next":{"title":"Quantifiers","permalink":"/z3guide/docs/logic/Quantifiers"}}');var r=t(4848),a=t(8453),i=t(6851);const o={title:"Uninterpreted Functions and Constants",sidebar_position:4},l=void 0,c={},u=[];function d(e){const n={code:"code",em:"em",p:"p",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"The basic building blocks of SMT formulas are constants and functions. Constants are just functions that take no arguments. So everything is really just a function."}),"\n",(0,r.jsx)(i.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-fun f (Int) Int)\\n(declare-fun a () Int) ; a is a constant\\n(declare-const b Int) ; syntax sugar for (declare-fun b () Int)\\n(assert (< a 20))\\n(assert (< b a))\\n(assert (= (f 10) 1))\\n(check-sat)\\n(get-model)","result":{"output":"sat\\n(\\n  (define-fun b () Int\\n    18)\\n  (define-fun a () Int\\n    19)\\n  (define-fun f ((x!0 Int)) Int\\n    1)\\n)\\n","error":"","status":"z3-ran","hash":"354bdae8bae85e785a511f6a86708e0b77594cc5"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,r.jsx)(n.p,{children:"Unlike programming languages, where functions have side-effects, can throw exceptions, or never return, functions in classical first-order logic have no side-effects and are total. That is, they are defined on all input values. This includes functions, such as division."}),"\n",(0,r.jsxs)(n.p,{children:["Function and constant symbols in pure first-order logic are ",(0,r.jsx)(n.em,{children:"uninterpreted"})," or ",(0,r.jsx)(n.em,{children:"free"}),", which means that no a priori interpretation is attached. This is in contrast to functions belonging to the signature of theories, such as arithmetic where the function + has a fixed standard interpretation (it adds two numbers). Uninterpreted functions and constants are maximally flexible; they allow any interpretation that is consistent with the constraints over the function or constant."]}),"\n",(0,r.jsx)(n.p,{children:"To illustrate uninterpreted functions and constants let us introduce an (uninterpreted) sort A, and the constants x, y ranging over A. Finally let f be an uninterpreted function that takes one argument of sort A and results in a value of sort A. The example illustrates how one can force an interpretation where f applied twice to x results in x again, but f applied once to x is different form x."}),"\n",(0,r.jsx)(i.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-sort A)\\n(declare-const x A)\\n(declare-const y A)\\n(declare-fun f (A) A)\\n(assert (= (f (f x)) x))\\n(assert (= (f x) y))\\n(assert (not (= x y)))\\n(check-sat)\\n(get-model)","result":{"output":"sat\\n(\\n  ;; universe for A:\\n  ;;   A!val!1 A!val!0 \\n  ;; -----------\\n  ;; definitions for universe elements:\\n  (declare-fun A!val!1 () A)\\n  (declare-fun A!val!0 () A)\\n  ;; cardinality constraint:\\n  (forall ((x A)) (or (= x A!val!1) (= x A!val!0)))\\n  ;; -----------\\n  (define-fun x () A\\n    A!val!0)\\n  (define-fun y () A\\n    A!val!1)\\n  (define-fun f ((x!0 A)) A\\n    (ite (= x!0 A!val!1) A!val!0\\n      A!val!1))\\n)\\n","error":"","status":"z3-ran","hash":"162f2246c1141d44617e16d5a65d06cf4d83196b"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,r.jsx)(n.p,{children:"The resulting model introduces abstract values for the elements in A, because the sort A is uninterpreted.\nThe interpretation for f in the model toggles between the two values for x and y, which are different."}),"\n",(0,r.jsxs)(n.p,{children:["The solver in z3 uses congruence closure to reason about equalities.\nCongruence closure allows inferring new equalities when the arguments to two applications\nof the same function are equal. In the example below, congruence closure infers that\n",(0,r.jsx)(n.code,{children:"x"})," equals ",(0,r.jsx)(n.code,{children:"(f x)"})," based on the first two assertions.\nSo the constraints become unsatisfiable when adding the disequality between\nthese two terms."]}),"\n",(0,r.jsx)(i.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-sort A)\\n(declare-fun f (A) A)\\n(declare-const x A)\\n(assert (= (f (f x)) x))\\n(assert (= (f (f (f x))) x))\\n(check-sat)\\n(get-model)\\n  \\n(assert (not (= (f x) x)))\\n(check-sat)","result":{"output":"sat\\n(\\n  ;; universe for A:\\n  ;;   A!val!0 \\n  ;; -----------\\n  ;; definitions for universe elements:\\n  (declare-fun A!val!0 () A)\\n  ;; cardinality constraint:\\n  (forall ((x A)) (= x A!val!0))\\n  ;; -----------\\n  (define-fun x () A\\n    A!val!0)\\n  (define-fun f ((x!0 A)) A\\n    A!val!0)\\n)\\nunsat\\n","error":"","status":"z3-ran","hash":"252e90a775621dde50161702454623b73d656f3d"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'})]})}function f(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);