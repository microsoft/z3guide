"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7864],{3798:(t,e,s)=>{s.r(e),s.d(e,{assets:()=>o,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>m});var n=s(7462),i=(s(7294),s(3905));s(7634);const a={title:"MBQI",sidebar_position:5},r=void 0,l={unversionedId:"Example Programs/MBQI",id:"Example Programs/MBQI",title:"MBQI",description:"In the following example we code a custom model-based quantifier instantiation procedure.",source:"@site/docs-programming/03 - Example Programs/05 - MBQI.md",sourceDirName:"03 - Example Programs",slug:"/Example Programs/MBQI",permalink:"/z3guide/programming/Example Programs/MBQI",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs-programming/03 - Example Programs/05 - MBQI.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"MBQI",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Formula Simplification",permalink:"/z3guide/programming/Example Programs/Formula Simplification"},next:{title:"Parameters",permalink:"/z3guide/programming/Parameters"}},o={},m=[],d={toc:m};function p(t){let{components:e,...s}=t;return(0,i.kt)("wrapper",(0,n.Z)({},d,s,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In the following example we code a custom model-based quantifier instantiation procedure.\nThe customized procedure uses models that prefer to set the\nfewest number of bits in bit-vector variables to 1.\nThe case study is described in ",(0,i.kt)("a",{parentName:"p",href:"https://z3prover.github.io/slides/z3internals.pptx"},"Z3 internals")," as a running example."),(0,i.kt)("p",null,"We start with importing the formula from a text string."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from z3 import *\n\ns = Solver()\ns.from_string("""\n(define-fun s4 () (_ BitVec 1) #b0)\n(declare-fun s0 () (_ BitVec 64))\n(declare-fun s1 () (_ BitVec 64))\n(assert (forall ((s2 (_ BitVec 64)))\n            (let ((s3 ((_ extract 7 7) s2)))\n            (let ((s5 (distinct s3 s4)))\n            (let ((s6 (bvand s0 s2)))\n            (let ((s7 (bvmul s1 s6)))\n            (let ((s8 ((_ extract 56 56) s7)))\n            (let ((s9 (distinct s4 s8)))\n            (let ((s10 (= s5 s9)))\n            (let ((s11 ((_ extract 15 15) s2)))\n            (let ((s12 (distinct s4 s11)))\n            (let ((s13 ((_ extract 57 57) s7)))\n            (let ((s14 (distinct s4 s13)))\n            (let ((s15 (= s12 s14)))\n            (let ((s16 ((_ extract 23 23) s2)))\n            (let ((s17 (distinct s4 s16)))\n            (let ((s18 ((_ extract 58 58) s7)))\n            (let ((s19 (distinct s4 s18)))\n            (let ((s20 (= s17 s19)))\n            (let ((s21 ((_ extract 31 31) s2)))\n            (let ((s22 (distinct s4 s21)))\n            (let ((s23 ((_ extract 59 59) s7)))\n            (let ((s24 (distinct s4 s23)))\n            (let ((s25 (= s22 s24)))\n            (let ((s26 ((_ extract 39 39) s2)))\n            (let ((s27 (distinct s4 s26)))\n            (let ((s28 ((_ extract 60 60) s7)))\n            (let ((s29 (distinct s4 s28)))\n            (let ((s30 (= s27 s29)))\n            (let ((s31 ((_ extract 47 47) s2)))\n            (let ((s32 (distinct s4 s31)))\n            (let ((s33 ((_ extract 61 61) s7)))\n            (let ((s34 (distinct s4 s33)))\n            (let ((s35 (= s32 s34)))\n            (let ((s36 ((_ extract 55 55) s2)))\n            (let ((s37 (distinct s4 s36)))\n            (let ((s38 ((_ extract 62 62) s7)))\n            (let ((s39 (distinct s4 s38)))\n            (let ((s40 (= s37 s39)))\n            (let ((s41 ((_ extract 63 63) s2)))\n            (let ((s42 (distinct s4 s41)))\n            (let ((s43 ((_ extract 63 63) s7)))\n            (let ((s44 (distinct s4 s43)))\n            (let ((s45 (= s42 s44)))\n            (let ((s46 (and s40 s45)))\n            (let ((s47 (and s35 s46)))\n            (let ((s48 (and s30 s47)))\n            (let ((s49 (and s25 s48)))\n            (let ((s50 (and s20 s49)))\n            (let ((s51 (and s15 s50)))\n            (let ((s52 (and s10 s51)))\n            s52)))))))))))))))))))))))))))))))))))))))))))))))))))\n\n""")\n\n')),(0,i.kt)("p",null,"Let us first create a version of the formula that is bit-blasted.\nFor this purpose we pre-process the formula with simplification and then invoke\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"bit-blast")," tactic. We have to set an option ",(0,i.kt)("inlineCode",{parentName:"p"},"blast_quant")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," in order\nto convert a quantified bit-vector variable to a set of quantified Booleans."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"\nt = Then(Tactic('simplify'), With(Tactic('bit-blast'), blast_quant=True))\n\ng = Goal()\ng.add(s.assertions())\nr = t(g)\nfml = r[0].as_expr()\n\n")),(0,i.kt)("p",null,"The formula ",(0,i.kt)("inlineCode",{parentName:"p"},"fml")," is a bit-blasted version of the original formula.",(0,i.kt)("br",{parentName:"p"}),"\n","We collect the free atomic Boolean variables in the bit-blasted formulas."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"\ndef is_uninterp(t):\n    return is_app(t) and t.decl().kind() == Z3_OP_UNINTERPRETED\n\ndef subterms(t):\n    def sub(t, ids, terms):\n        if t.get_id() in ids:\n            return\n        ids |= { t.get_id() }\n        terms += [ t ]\n        for s in t.children():\n            sub(s, ids, terms)\n        return terms\n    return sub(t, set([]), [])\n\ndef get_bits(fml):\n    return { t for t in subterms(fml) if is_uninterp(t) }\n\n")),(0,i.kt)("p",null,"Z3 introduces fresh ",(0,i.kt)("em",{parentName:"p"},"internal")," uninterpreted constants in the process of bit-blasting.\nThe fresh ",(0,i.kt)("em",{parentName:"p"},"internal")," uninterpreted constants are hidden from models, so to\nbe able to retrieve model values for the fresh constants, we\nrename them back to ",(0,i.kt)("em",{parentName:"p"},"external")," constants. The function ",(0,i.kt)("inlineCode",{parentName:"p"},"substitute")," is used to replace sub-terms.\nIt required a list of pairs as input."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'orig_bits = get_bits(fml.body())\norig2bit = { b : Bool(f"x{b}") for b in orig_bits }\nbits = list(orig2bit.values())\nfml = substitute(fml, list(orig2bit.items()))\n')),(0,i.kt)("p",null,"We also create atomic constants for the bound variables.\nThe function ",(0,i.kt)("inlineCode",{parentName:"p"},"substitute_vars")," replaces free de-Bruijn index variables by the terms supplied\nas the second argument."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'vars = Bools([f"x{i}" for i in range(fml.num_vars())])\nfml = fml.body()\nfml = substitute_vars(fml, *vars)\n')),(0,i.kt)("p",null,"We are now ready for an MBQI loop that uses optimization to\nalways find a model that sets the fewest bits to true.\nThis is both for models of the outer constraints and\nfor models of the negated body."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'fmls = []\nwhile True:\n    opt = Optimize()\n    opt.add(fmls)\n    for b in bits:\n        opt.add_soft(Not(b))\n    if unsat == opt.check():\n        print("Unsat")\n        break\n    M = opt.model()\n    checker = Optimize()\n    sub = [(bit, M.eval(bit)) for bit in bits]\n    print(sub)\n    inst = simplify(substitute(fml, sub))\n    checker.add(Not(inst))\n    for b in vars:\n        checker.add_soft(Not(b))\n    if unsat == checker.check():\n        print("Sat", M)\n        break\n    M = checker.model()\n    fml1 = simplify(substitute(fml, [(b, M.eval(b)) for b in vars]))\n    print(fml1)\n    fmls += [fml1]\n')))}p.isMDXComponent=!0}}]);