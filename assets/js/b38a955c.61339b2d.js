"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[4705],{6587(e,n,t){t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>a,default:()=>f,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"logic/Recursive Functions","title":"Recursive Functions","description":"SMTLIB2 standard: Page 62","source":"@site/docs-smtlib/01 - logic/07 - Recursive Functions.md","sourceDirName":"01 - logic","slug":"/logic/Recursive Functions","permalink":"/z3guide/docs/logic/Recursive Functions","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/01 - logic/07 - Recursive Functions.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Recursive Functions","sidebar_position":7},"sidebar":"smtlibSidebar","previous":{"title":"Lambdas","permalink":"/z3guide/docs/logic/Lambdas"},"next":{"title":"Conclusion","permalink":"/z3guide/docs/logic/Conclusion"}}');var s=t(4848),r=t(8453),o=t(6851);const l={title:"Recursive Functions",sidebar_position:7},a=void 0,u={},c=[{value:"Mutually Recursive Functions",id:"mutually-recursive-functions",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",em:"em",h2:"h2",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"SMTLIB2"})," standard: ",(0,s.jsx)(n.a,{href:"https://smt-lib.org/papers/smt-lib-reference-v2.6-r2021-05-12.pdf",children:"Page 62"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"You can define recursive functions"}),"\n",(0,s.jsx)(o.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(define-fun-rec length ((ls (List Int))) Int\\n   (if ((_ is nil) ls) 0 (+ 1 (length (tail ls)))))\\n\\n(define-fun-rec nat-list ((ls (List Int))) Bool \\n   (if ((_ is nil) ls)\\n       true\\n       (and (>= (head ls) 0) (nat-list (tail ls)))))\\n\\n(declare-const list1 (List Int))\\n(declare-const list2 (List Int))\\n(assert (> (length list1) (length list2)))\\n(assert (not (nat-list list2)))\\n(assert (nat-list list1))\\n(check-sat)\\n(get-model)","result":{"output":"sat\\n(\\n  (define-fun list2 () (List Int)\\n    (insert (- 1) nil))\\n  (define-fun list1 () (List Int)\\n    (insert 0 (insert 7629 nil)))\\n)\\n","error":"","status":"z3-ran","hash":"35cba896a1defa79c96cc34a9e7ac3346d19429d"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,s.jsxs)(n.p,{children:["Z3 unfolds the definition of recursive functions incrementally by iterative deepening:\nit attempts first to establish satisfiability modulo a fixed bound on number of unfoldings;\nif the resulting formula is unsatisfiable ",(0,s.jsx)(n.em,{children:"and"})," the reason for unsatisfiability is due to the\nbound restriction, it increases the fixed bound incrementally. Note that this approach does not\ninvolve reasoning by induction that is often required to prove deeper properties of recursive functions.\nThis scheme allows to decide satisfiability and unsatisfiability for a limited, but often useful,\nclass of formulas."]}),"\n",(0,s.jsx)(n.h2,{id:"mutually-recursive-functions",children:"Mutually Recursive Functions"}),"\n",(0,s.jsx)(n.p,{children:"You can also define functions that are mutually recursive.\nThe syntax requires to declare all functions first in one block, and then\ndefine the bodies of the recursive functions in a second block."}),"\n",(0,s.jsx)(o.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(define-funs-rec \\n   ((ping ((x Int) (y Bool)) Int)\\n    (pong ((a Int) (b Bool)) Int))\\n\\n   ((if y (pong (+ x 1) (not y)) (- x 1))\\n    (if b (ping (- a 1) (not b)) a)))\\n\\n(declare-const x Int)\\n(assert (> x 0))\\n(assert (> (ping x true) x))\\n(check-sat)\\n(get-model)","result":{"output":"sat\\n(\\n  (define-fun x () Int\\n    1)\\n)\\n","error":"","status":"z3-ran","hash":"b7eb21ec9b1862b9632df83a50f5989422c1a24e"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'})]})}function f(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);