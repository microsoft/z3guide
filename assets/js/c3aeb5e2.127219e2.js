"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7569],{2253:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>f,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"optimization/softconstraints","title":"Soft Constraints","description":"The (assert-soft formula [id id]) command asserts a weighted soft constraint. The weight must be a positive natural number, but is optional. If omitted, the weight is set to 1.","source":"@site/docs-smtlib/04 - optimization/04 - softconstraints.md","sourceDirName":"04 - optimization","slug":"/optimization/softconstraints","permalink":"/z3guide/docs/optimization/softconstraints","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/04 - optimization/04 - softconstraints.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Soft Constraints","sidebar_position":4},"sidebar":"smtlibSidebar","previous":{"title":"Arithmetical Optimization","permalink":"/z3guide/docs/optimization/arithmeticaloptimization"},"next":{"title":"Combining Objectives","permalink":"/z3guide/docs/optimization/combiningobjectives"}}');var o=n(4848),i=n(8453),a=n(6851);const r={title:"Soft Constraints",sidebar_position:4},l=void 0,c={},d=[];function u(e){const t={code:"code",p:"p",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"(assert-soft formula [:weight numeral] [:id id])"})," command asserts a weighted soft constraint. The weight must be a positive natural number, but is optional. If omitted, the weight is set to 1."]}),"\n",(0,o.jsx)(a.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const x Int)\\n(declare-const y Int)\\n(define-fun a1 () Bool (> x 0))\\n(define-fun a2 () Bool (< x y))\\n(define-fun a3 () Bool (<= (+ y x) 0))\\n(assert (= a3 a1))\\n(assert (or a3 a2))\\n(assert-soft a3         :weight 3)\\n(assert-soft (not a3)   :weight 5) \\n(assert-soft (not a1)   :weight 10)\\n(assert-soft (not a2)   :weight 3)\\n(check-sat)\\n(get-model)\\n(get-objectives)\\n(eval a1)\\n(eval a2)\\n(eval a3)","result":{"output":"sat\\n(\\n  (define-fun y () Int\\n    1)\\n  (define-fun x () Int\\n    0)\\n  (define-fun a3 () Bool\\n    (<= (+ y x) 0))\\n  (define-fun a2 () Bool\\n    (< x y))\\n  (define-fun a1 () Bool\\n    (> x 0))\\n)\\n(objectives\\n ( 6)\\n)\\nfalse\\ntrue\\nfalse\\n","error":"","status":"z3-ran","hash":"3ce6d4cb26efea3101c022ff1e456279f086d14b"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.12.1","tool":"z3-solver"}'}),"\n",(0,o.jsx)(t.p,{children:"Floating point and integer weights can be mixed; internally weights are converted into rational numbers."}),"\n",(0,o.jsx)(a.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const a1 Bool)\\n(declare-const a2 Bool)\\n(declare-const a3 Bool)\\n(assert-soft a1 :weight 0.1)\\n(assert-soft a2 :weight 1.0)\\n(assert-soft a3 :weight  1)\\n(assert-soft (or (not a1) (not a2)) :weight 3.2)\\n(check-sat)\\n(get-objectives)\\n(get-model)","result":{"output":"sat\\n(objectives\\n ( (/ 1.0 10.0))\\n)\\n(\\n  (define-fun a3 () Bool\\n    true)\\n  (define-fun a1 () Bool\\n    false)\\n  (define-fun a2 () Bool\\n    true)\\n)\\n","error":"","status":"z3-ran","hash":"51dfef1d95809aeb7038bf631873cec94318c1e3"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.12.1","tool":"z3-solver"}'}),"\n",(0,o.jsxs)(t.p,{children:["You can use identifiers to group soft constraints. You can also repeat the same soft constraint. Every repetition counts independently. In the example we add the soft constraint ",(0,o.jsx)(t.code,{children:"a"})," twice and force it to be false. The penalty for group ",(0,o.jsx)(t.code,{children:"x"})," is therefore 2. The penalty for group ",(0,o.jsx)(t.code,{children:"y"})," is because there is only one soft constraint that is impossible to satisfy."]}),"\n",(0,o.jsx)(a.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const a Bool)\\n(declare-const b Bool)\\n(assert-soft false :id y)\\n(assert-soft a :id x)\\n(assert-soft a :id x)\\n(assert-soft b :id x)\\n(assert (not a))\\n\\n(check-sat)\\n(get-objectives)","result":{"output":"sat\\n(objectives\\n (y 1)\\n (x 2)\\n)\\n","error":"","status":"z3-ran","hash":"89934f7c722a84254e253104c0d0cca647ca851c"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.12.1","tool":"z3-solver"}'})]})}function f(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}}}]);