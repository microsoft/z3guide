"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7035],{5581:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"fixedpoints/engineforpdr","title":"Generalized PDR with SPACER","description":"A different underlying engine for fixed-points is based on the SPACER algorithm for","source":"@site/docs-smtlib/05 - fixedpoints/03 - engineforpdr.md","sourceDirName":"05 - fixedpoints","slug":"/fixedpoints/engineforpdr","permalink":"/z3guide/docs/fixedpoints/engineforpdr","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/05 - fixedpoints/03 - engineforpdr.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Generalized PDR with SPACER","sidebar_position":3},"sidebar":"smtlibSidebar","previous":{"title":"Basic Datalog","permalink":"/z3guide/docs/fixedpoints/basicdatalog"},"next":{"title":"Syntax","permalink":"/z3guide/docs/fixedpoints/syntax"}}');var i=t(4848),a=t(8453),s=t(6851);const o={title:"Generalized PDR with SPACER",sidebar_position:3},d=void 0,l={},c=[{value:"Procedure Calls",id:"procedure-calls",level:2}];function u(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["A different underlying engine for fixed-points is based on the SPACER algorithm for\nProperty Directed Reachability ",(0,i.jsx)(n.a,{href:"https://spacer.bitbucket.io/",children:"(PDR)"}),". The PDR engine is used by default for relations over integers, reals and algebraic data-types. The version in Z3 applies to Horn clauses with arithmetic and Boolean domains. The engine also works with domains using arrays, algebraic data-types and bit-vectors. The PDR engine is targeted at applications from symbolic model checking of software. The systems may be infinite state. The following examples also serve a purpose of showing how software model checking problems (of safety properties) can be embedded into Horn clauses and solved using PDR."]}),"\n",(0,i.jsx)(n.h2,{id:"procedure-calls",children:"Procedure Calls"}),"\n",(0,i.jsx)(n.p,{children:"McCarthy's 91 function illustrates a procedure that calls itself recursively twice. The Horn clauses below encode the recursive function:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"  mc(x) = if x > 100 then x - 10 else mc(mc(x+11))\n"})}),"\n",(0,i.jsx)(n.p,{children:"The general scheme for encoding recursive procedures is by creating a predicate for each procedure and adding an additional output variable to the predicate. Nested calls to procedures within a body can be encoded as a conjunction of relations."}),"\n",(0,i.jsx)(s.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-rel mc (Int Int))\\n(declare-var n Int)\\n(declare-var m Int)\\n(declare-var p Int)\\n\\n(rule (=> (> m 100) (mc m (- m 10))))\\n(rule (=> (and (<= m 100) (mc (+ m 11) p) (mc p n)) (mc m n)))\\n\\n(declare-rel q1 (Int Int))\\n(rule (=> (and (mc m n) (< n 91)) (q1 m n))) \\n(query q1 :print-certificate true)\\n\\n(declare-rel q2 (Int Int))\\n(rule (=> (and (mc m n) (not (= n 91)) (<= m 101)) (q2 m n)))\\n(query q2 :print-certificate true)\\n\\n(declare-rel q3 (Int Int))\\n(rule (=> (and (mc m n) (< n 92)) (q3 m n)))\\n(query q3 :print-certificate true)","result":{"output":"unsat\\n(forall ((A Int) (B Int)) (! (= (mc A B) (not (<= B 90))) :weight 0))\\nunsat\\n(forall ((A Int) (B Int))\\n  (! (let ((a!1 (not (<= (+ A (* (- 1) B)) 9))))\\n     (let ((a!2 (and (or (not (>= B 92)) a!1) (not (<= B 90)))))\\n       (= (mc A B) a!2)))\\n     :weight 0))\\nsat\\n(let ((a!1 (forall ((A Int) (B Int))\\n             (! (=> (and (mc A B) (not (<= 92 B))) (query!24 B A)) :weight 0)))\\n      (a!2 (forall ((A Int) (B Int))\\n             (! (=> (and (not (<= B 100)) (= A (+ (- 10) B))) (mc B A))\\n                :weight 0))))\\n  (mp ((_ hyper-res 0 0 0 1)\\n        (asserted a!1)\\n        ((_ hyper-res 0 0) (asserted a!2) (mc 101 91))\\n        (query!24 91 101))\\n      (asserted (=> (query!24 91 101) false))\\n      false))\\n","error":"","status":"z3-ran","hash":"de18e332acbefeaf89910ad56939cdadd7bc00c4"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);