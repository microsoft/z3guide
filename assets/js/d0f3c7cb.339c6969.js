"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1967],{4230:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>n,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"optimization/advancedtopics","title":"Advanced Topics","description":"Difference Logic","source":"@site/docs-smtlib/04 - optimization/07 - advancedtopics.md","sourceDirName":"04 - optimization","slug":"/optimization/advancedtopics","permalink":"/z3guide/docs/optimization/advancedtopics","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/04 - optimization/07 - advancedtopics.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Advanced Topics","sidebar_position":7},"sidebar":"smtlibSidebar","previous":{"title":"A Small Case Study","permalink":"/z3guide/docs/optimization/asmallcasestudy"},"next":{"title":"Introduction","permalink":"/z3guide/docs/fixedpoints/intro"}}');var s=r(4848),i=r(8453),a=r(6851);const n={title:"Advanced Topics",sidebar_position:7},l=void 0,c={},d=[{value:"Difference Logic",id:"difference-logic",level:2},{value:"Weighted Max-SAT solvers, a portfolio",id:"weighted-max-sat-solvers-a-portfolio",level:2}];function u(e){const t={code:"code",em:"em",h2:"h2",p:"p",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"difference-logic",children:"Difference Logic"}),"\n",(0,s.jsxs)(t.p,{children:["By default, Z3 uses dual Simplex to solve feasibility, and primal Simplex for optimality.\nFor arithmetical constraints that only have differences between variables, known as ",(0,s.jsx)(t.em,{children:"difference logic"}),", Z3 contains alternative decision procedures tuned for this domain. These have to be configured explicitly. There is a choice between a solver tuned for sparse constraints (where the ratio of variables is high compared to number of inequalities) and a solver tuned for dense constraints."]}),"\n",(0,s.jsx)(a.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(set-option :smt.arith.solver 1) ; enables difference logic solver for sparse constraints\\n(set-option :smt.arith.solver 3) ; enables difference logic solver for dense constraints\\n(declare-const x Int)\\n(declare-const y Int)\\n(assert (>= 10 x))\\n(assert (>= x (+ y 7)))\\n(maximize (+ x y))\\n(check-sat)\\n(get-objectives)","result":{"output":"sat\\n(objectives\\n ((+ x y) 13)\\n)\\n","error":"","status":"z3-ran","hash":"ea20b2d96ae94697685162c29a703cbcbd314f11"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,s.jsx)(t.h2,{id:"weighted-max-sat-solvers-a-portfolio",children:"Weighted Max-SAT solvers, a portfolio"}),"\n",(0,s.jsxs)(t.p,{children:["The default solver for MaxSAT problems is the MaxRes algorithm.\nSeveral alternative solvers are available. The default solver\nis chosen based on benchmarking against MaxSAT competition benchmarks, but other solver combinations, such as ",(0,s.jsx)(t.code,{children:"wmax"}),", may work well for some domains.\nWhen the objectives have weights such as 1, 2, 4, 8, 16, such that the sum of weights in every prefix is lower than the next weight, the solver\nuses a lexicographic optimization algorithm that attempts to first solve for the highest weight before continuing with lower weights."]}),"\n",(0,s.jsx)(t.p,{children:"The other main MaxSAT algorithms available are"}),"\n",(0,s.jsx)(a.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"  (set-option :opt.maxsat_engine rc2)\\n  (set-option :opt.maxsat_engine maxresbin)\\n  (set-option :opt.maxsat_engine wmax)","result":{"output":"","error":"","status":"z3-ran","hash":"5612c6ae0f95654fe78d644ea22c38c89603d085"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,s.jsx)(t.p,{children:"Pre-processing within the optimization solver will attempt to eliminate bounded arithmetical variables.\nFor example, the constraints"}),"\n",(0,s.jsx)(a.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-fun x () Int)\\n(assert (<= x 1))\\n(assert (>= x 0))\\n(minimize x)\\n(check-sat)","result":{"output":"sat\\n","error":"","status":"z3-ran","hash":"17c562d7ea9558b313919eb0d034825a837681de"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,s.jsx)(t.p,{children:"are rewritten internally to a problem of the form"}),"\n",(0,s.jsx)(a.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const x Bool)\\n(assert-soft (not x))\\n(check-sat)","result":{"output":"sat\\n","error":"","status":"z3-ran","hash":"7383c53cbd0c74c15a7b0b9923fbedef1afb7023"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,s.jsx)(t.p,{children:"You can disable this transformation by setting"}),"\n",(0,s.jsx)(a.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"  (set-option :opt.elim_01 false)","result":{"output":"","error":"","status":"z3-ran","hash":"f7ac4e436fe82cad790e178cc19ada922f00de9b"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,s.jsx)(t.p,{children:"For problems that are already bit-vector or Boolean, or can be rewritten to this form, the engine uses a core solver based on a tuned SAT solver.\nYou can turn off the use of the SAT solver by setting:"}),"\n",(0,s.jsx)(a.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"  (set-option :opt.enable_sat false)","result":{"output":"","error":"","status":"z3-ran","hash":"a2353be83ff1e37afff17c6b311cd760c0add3ce"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);