"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8105],{9649:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>b,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"optimization/combiningobjectives","title":"Combining Objectives","description":"Many optimization problems require solving multiple objectives.","source":"@site/docs-smtlib/04 - optimization/05 - combiningobjectives.md","sourceDirName":"04 - optimization","slug":"/optimization/combiningobjectives","permalink":"/z3guide/docs/optimization/combiningobjectives","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/04 - optimization/05 - combiningobjectives.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Combining Objectives","sidebar_position":5},"sidebar":"smtlibSidebar","previous":{"title":"Soft Constraints","permalink":"/z3guide/docs/optimization/softconstraints"},"next":{"title":"A Small Case Study","permalink":"/z3guide/docs/optimization/asmallcasestudy"}}');var o=n(4848),s=n(8453),r=n(6851);const a={title:"Combining Objectives",sidebar_position:5},c=void 0,l={},d=[{value:"Lexicographic Combination",id:"lexicographic-combination",level:2},{value:"Pareto Fronts",id:"pareto-fronts",level:2},{value:"Independent Objectives",id:"independent-objectives",level:2}];function u(e){const t={a:"a",code:"code",h2:"h2",p:"p",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"Many optimization problems require solving multiple objectives."}),"\n",(0,o.jsx)(t.h2,{id:"lexicographic-combination",children:"Lexicographic Combination"}),"\n",(0,o.jsx)(t.p,{children:"Z3 uses by default a lexicographic priority of objectives. It solves first for the objective that is declared first."}),"\n",(0,o.jsx)(r.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const x Int)\\n(declare-const y Int)\\n(declare-const z Int)\\n(assert (< x z))\\n(assert (< y z))\\n(assert (< z 5))\\n(assert (not (= x y)))\\n(maximize x)\\n(maximize y)\\n(check-sat)\\n(get-model)\\n(get-objectives)","result":{"output":"sat\\n(\\n  (define-fun z () Int\\n    4)\\n  (define-fun x () Int\\n    3)\\n  (define-fun y () Int\\n    2)\\n)\\n(objectives\\n (x 3)\\n (y 2)\\n)\\n","error":"","status":"z3-ran","hash":"6657f23e42e9d33a43710ffb211beb03894d4bc6"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,o.jsxs)(t.p,{children:["It is also possible to declare multiple classes of soft assertions. To do this, use an optional tag to differentiate classes of soft assertions.\nThe first tag group ",(0,o.jsx)(t.code,{children:"A"})," is given precedence over the second group ",(0,o.jsx)(t.code,{children:"B"})," that is introduced later."]}),"\n",(0,o.jsx)(r.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const a Bool)\\n(declare-const b Bool)\\n(declare-const c Bool)\\n(assert-soft a :weight 1 :id A)\\n(assert-soft b :weight 2 :id B)\\n(assert-soft c :weight 3 :id A)\\n(assert (= a c))\\n(assert (not (and a b)))\\n(check-sat)\\n(get-model)\\n(get-objectives)","result":{"output":"sat\\n(\\n  (define-fun c () Bool\\n    true)\\n  (define-fun b () Bool\\n    false)\\n  (define-fun a () Bool\\n    true)\\n)\\n(objectives\\n (A 0)\\n (B 2)\\n)\\n","error":"","status":"z3-ran","hash":"9f2cf4d1ad165a3bf496a5480ae5fe3ded4836c7"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,o.jsx)(t.h2,{id:"pareto-fronts",children:"Pareto Fronts"}),"\n",(0,o.jsxs)(t.p,{children:["To override lexicographic priorities, set the option opt.priority to ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Pareto_front",children:"Pareto"}),"."]}),"\n",(0,o.jsx)(r.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const x Int)\\n(declare-const y Int)\\n(assert (>= 5 x))\\n(assert (>= x 0))\\n(assert (>= 4 y))\\n(assert (>= y 0))\\n(minimize x)\\n(maximize (+ x y))\\n(minimize y)\\n(set-option :opt.priority pareto)\\n(check-sat)\\n(get-objectives)\\n(check-sat)\\n(get-objectives)\\n(check-sat)\\n(get-objectives)\\n(check-sat)\\n(get-objectives)","result":{"output":"sat\\n(objectives\\n (x 0)\\n ((+ x y) 0)\\n (y 0)\\n)\\nsat\\n(objectives\\n (x 0)\\n ((+ x y) 1)\\n (y 1)\\n)\\nsat\\n(objectives\\n (x 0)\\n ((+ x y) 2)\\n (y 2)\\n)\\nsat\\n(objectives\\n (x 0)\\n ((+ x y) 3)\\n (y 3)\\n)\\n","error":"","status":"z3-ran","hash":"3bdd9d525310aedaecd3ef496845047efb0f0bd9"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,o.jsx)(t.h2,{id:"independent-objectives",children:"Independent Objectives"}),"\n",(0,o.jsx)(t.p,{children:"If we just want to find the optimal value for each objective, set the option opt.priority to box."}),"\n",(0,o.jsx)(r.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const x Real)\\n(declare-const y Real)\\n(assert (>= 5 (- x y)))\\n(assert (>= x 0))\\n(assert (>= 4 y))\\n(assert (> y 0))\\n(minimize x)\\n(maximize (+ x y))\\n(minimize y)\\n(maximize y)\\n(set-option :opt.priority box)\\n(check-sat)\\n(get-objectives)","result":{"output":"sat\\n(objectives\\n (x 0)\\n ((+ x y) oo)\\n (y (* (- 1) oo))\\n (y oo)\\n)\\n","error":"","status":"z3-ran","hash":"2b923d85c21f20c2953ebd568e15f45c796804a3"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'})]})}function b(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}}}]);