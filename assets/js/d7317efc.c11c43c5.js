"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3229],{5408(e,n,a){a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"logic/Lambdas","title":"Lambdas","description":"Lambda binding is available as an extension to the theory of arrays.","source":"@site/docs-smtlib/01 - logic/06 - Lambdas.md","sourceDirName":"01 - logic","slug":"/logic/Lambdas","permalink":"/z3guide/docs/logic/Lambdas","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/01 - logic/06 - Lambdas.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Lambdas","sidebar_position":6},"sidebar":"smtlibSidebar","previous":{"title":"Quantifiers","permalink":"/z3guide/docs/logic/Quantifiers"},"next":{"title":"Recursive Functions","permalink":"/z3guide/docs/logic/Recursive Functions"}}');var t=a(4848),r=a(8453),i=a(6851);const o={title:"Lambdas",sidebar_position:6},l=void 0,d={},c=[{value:"Syntax and Semantics",id:"syntax-and-semantics",level:2},{value:"Inlining definitions using Lambda",id:"inlining-definitions-using-lambda",level:2},{value:"Lambdas as Arrays",id:"lambdas-as-arrays",level:2},{value:"From First-Order to limited Higher-Order",id:"from-first-order-to-limited-higher-order",level:2}];function h(e){const n={annotation:"annotation",code:"code",em:"em",h2:"h2",math:"math",mi:"mi",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Lambda binding is available as an extension to the theory of arrays."}),"\n",(0,t.jsx)(n.h2,{id:"syntax-and-semantics",children:"Syntax and Semantics"}),"\n",(0,t.jsx)(n.p,{children:"Lambda expressions use syntax similar to quantifiers. It is of the form:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"(lambda ((x X) (y Y) (z Z)) t)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["where ",(0,t.jsx)(n.code,{children:"x y z"})," are lambda bound variables and ",(0,t.jsx)(n.code,{children:"t"})," is an expression that can contain the bound variables."]}),"\n",(0,t.jsxs)(n.p,{children:["The laws of lambda calculus apply.\nThe simplifier performs ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{children:"\u03b2"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\beta"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.05278em"},children:"\u03b2"})]})})]})," reduction."]}),"\n",(0,t.jsx)(i.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const a Int)\\n(declare-const b Int)\\n(declare-const c Int)\\n(simplify (select (lambda ((x Int) (y Int) (z Int)) (+ x (* z y))) a b c))","result":{"output":"(+ a (* b c))\\n","error":"","status":"z3-ran","hash":"305bab96916b791b6b23058250400c37e8ff4ee9"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,t.jsxs)(n.p,{children:["Other rules ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{children:"\u03b1"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\alpha"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.0037em"},children:"\u03b1"})]})})]})," (renaming) and ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{children:"\u03b7"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\eta"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"\u03b7"})]})})]})," (extensionality) are enforced by the solver."]}),"\n",(0,t.jsx)(n.h2,{id:"inlining-definitions-using-lambda",children:"Inlining definitions using Lambda"}),"\n",(0,t.jsxs)(n.p,{children:["The main utility of lambdas in Z3 is for introducing inline definitions as the following ",(0,t.jsx)(n.code,{children:"memset"})," example illustrates."]}),"\n",(0,t.jsx)(i.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const m (Array Int Int))\\n(declare-const m1 (Array Int Int))\\n(declare-const z Int)\\n(define-fun memset ((lo Int) (hi Int) (y Int) (m (Array Int Int))) \\n                   (Array Int Int) \\n           (lambda ((x Int)) (if (and (<= lo x) (<= x hi)) y (m x))))\\n(assert (= m1 (memset 1 700 z m)))\\n(assert (not (= (select m1 6) z)))\\n(check-sat)","result":{"output":"unsat\\n","error":"","status":"z3-ran","hash":"34669b249cfcde8700c68127b6b4cb22de9c24c1"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,t.jsxs)(n.p,{children:["Note that the type of ",(0,t.jsx)(n.code,{children:"(lambda ((x Int)) (if (and (<= lo x) (<= x hi)) y (m x)))"})," is ",(0,t.jsx)(n.code,{children:"(Array Int Int)"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"lambdas-as-arrays",children:"Lambdas as Arrays"}),"\n",(0,t.jsx)(n.p,{children:"Thus, the type of a lambda expression is an array where the domain of the\narray are the argument types and the range is the sort of the body of the lambda expression."}),"\n",(0,t.jsxs)(n.p,{children:["Thus, in z3 arrays are synonymous with function spaces. You can transition between arrays and\nfunctions using ",(0,t.jsx)(n.code,{children:"as-array"})," to convert a function to an array and using function macros to treat an array as a function.\nThe example also illustrates a subtle use of recursive function declarations.\nFunctions declared using ",(0,t.jsx)(n.code,{children:"define-fun-rec"})," are expanded on demand and therefore the function symbols are available as arguments to ",(0,t.jsx)(n.code,{children:"as-array"}),".\nThis contrasts with functions declared using ",(0,t.jsx)(n.code,{children:"define-fun"})," that are treated as macros that are expanded at parse time. Their function symbols cannot be passed to ",(0,t.jsx)(n.code,{children:"as-array"}),"."]}),"\n",(0,t.jsx)(i.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-fun f (Int) Int)\\n(push)\\n(assert (not (=  (select (_ as-array f) 0) (f 0))))\\n(check-sat)\\n(pop)\\n(push)\\n(declare-const a (Array Int Int))\\n(define-fun-rec f2 ((x Int)) Int (select a x))\\n(assert (not (= (select a 0) (select (_ as-array f2) 0))))\\n(check-sat)\\n(pop)","result":{"output":"unsat\\nunsat\\n","error":"","status":"z3-ran","hash":"05ef8dbc1a28e809e1b9b207d43ec0a28e460341"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,t.jsx)(n.h2,{id:"from-first-order-to-limited-higher-order",children:"From First-Order to limited Higher-Order"}),"\n",(0,t.jsxs)(n.p,{children:["There is limited true higher order reasoning. One basic example that ",(0,t.jsx)(n.em,{children:"does"})," work thanks to model construction of MBQI instantiation procedure\nis establishing a second-order definition for equality."]}),"\n",(0,t.jsx)(i.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const x Int)\\n(declare-const y Int)\\n(assert (forall ((q (Array Int Bool))) (= (q x) (q y))))\\n(assert (not (= x y)))\\n(check-sat)","result":{"output":"unsat\\n","error":"","status":"z3-ran","hash":"a11fa748d489af6654b5345cbe05536dbd6cc5b0"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.15.1","tool":"z3-solver"}'}),"\n",(0,t.jsxs)(n.p,{children:["During instantiation, z3 determines to instantiate ",(0,t.jsx)(n.code,{children:"q"})," with the term ",(0,t.jsx)(n.code,{children:"(lambda ((z Int)) (= x z))"})," and therefore it infers the fact ",(0,t.jsx)(n.code,{children:"(= (= x x) (= x y))"}),".\nNote that the example illustrates using an array as a function application. We wrote ",(0,t.jsx)(n.code,{children:"(q x)"})," instead of ",(0,t.jsx)(n.code,{children:"(select q x)"})," for the array ",(0,t.jsx)(n.code,{children:"q"}),".\nIt is a feature that is supported as a convenience: the parser performs a best-effort coercions to insert ",(0,t.jsx)(n.code,{children:"select"})," automatically."]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}}}]);