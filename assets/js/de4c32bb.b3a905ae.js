"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3505],{6021:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>d,toc:()=>f});var a=n(3117),o=(n(7294),n(3905)),r=n(504),s=n.n(r);const i={title:"User Propagators",sidebar_position:2},l=void 0,d={unversionedId:"Examples/User Propagator",id:"Examples/User Propagator",title:"User Propagators",description:"User propagators allow implementing custom theory solvers outside of z3.",source:"@site/docs-programming/03 - Examples/02 - User Propagator.md",sourceDirName:"03 - Examples",slug:"/Examples/User Propagator",permalink:"/z3guide/programming/Examples/User Propagator",draft:!1,editUrl:"https://github.com/microsoft/z3guide/tree/main/website/docs-programming/03 - Examples/02 - User Propagator.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"User Propagators",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Cores and Satisfying Subsets",permalink:"/z3guide/programming/Examples/Cores and Satisfying Subsets"},next:{title:"SPACER",permalink:"/z3guide/programming/Examples/SPACER"}},u={},f=[{value:"A Problem Instance",id:"a-problem-instance",level:2},{value:"Propagate Functions",id:"propagate-functions",level:2},{value:"Axiomatizing RTCs",id:"axiomatizing-rtcs",level:2},{value:"Union Find",id:"union-find",level:2},{value:"Finally, the propagator",id:"finally-the-propagator",level:2},{value:"TC as a subclass",id:"tc-as-a-subclass",level:3},{value:"Handling assignments to fixed values",id:"handling-assignments-to-fixed-values",level:3},{value:"New Terms",id:"new-terms",level:3},{value:"Equality callbacks",id:"equality-callbacks",level:3},{value:"Final check",id:"final-check",level:3},{value:"Using the User Propagator",id:"using-the-user-propagator",level:2}],c={toc:f};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"User propagators allow implementing custom theory solvers outside of z3.\nThe following example illustrates using propagators for solving over the\nreflexive transitive closure (RTC) of a binary relation over a finite domain.\nIt is possible to axiomatize the reflexive transitive closure as a finite lookup table,\nbut the representation explodes (quadratically) when the size of the finite domain is large."),(0,o.kt)("p",null,"We represent the relation outside of z3. For sake of simplicity the example maintains the RTC\nas a lookup table as well (so it does not scale as well as an an implicit representation of the RTC).\nIt also only implements a very basic set of rules for enforcing RTC over the finite domain.\nWe leave optimizations as a fun project you could explore while learning User Propagators.\nFor example, you can implement inference rules that check that the asserted binary relations\nare consistent with the rules of transitivity."),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"Programming decision procedures is generally not a trivial task. The UserPropagate API attempts to enable new decision procedures and keeping a relatively low barrier of entry. Nevertheless, even a simple theory that we are going to explore exhibits its own subtleties. Program user propagators at your own risk.")),(0,o.kt)("h2",{id:"a-problem-instance"},"A Problem Instance"),(0,o.kt)("p",null,"We take a problem instance from a user GitHub question on how to scale reasoning with RTC.\nThe smaller example uses two relations ",(0,o.kt)("inlineCode",{parentName:"p"},"<=Sort")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"<=SortSyntax")," that are reflexive and transitive\nand they are defined over the finite enumeration sort ",(0,o.kt)("inlineCode",{parentName:"p"},"Sort"),". We elide the declarations of the\ntwo binary relations in the input and instead declare them outside of SMTLIB.\nThis allows us to declare the relations such that the propagator is notified whenever a new\npredicate over ",(0,o.kt)("inlineCode",{parentName:"p"},"<=Sort")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"<=SortSyntax")," is created."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-pyhon"},'from z3 import *\n\nexample = """\n\n(declare-datatypes () ((Sort\n(|SortInt| )\n(|SortExp| )\n(|SortKItem| )\n(|SortKLabel| )\n(|SortK| )\n)))\n\n;(declare-fun <=Sort (Sort Sort) Bool)\n;(declare-fun <=SortSyntax (Sort Sort) Bool)\n\n\n(declare-const |FreshVarSort_6_8_6_36_#KRewrite| Sort)\n(declare-const |VarA| Sort)\n(declare-const |VarB| Sort)\n(declare-const |VarC| Sort)\n(declare-datatypes() ((SolutionVariables (SolVars (|Sol_VarA| Sort) (|Sol_VarB| Sort) (|Sol_VarC| Sort) ))))\n(declare-datatypes() ((Solution (Sol (vars SolutionVariables) (|Sol_FreshVarSort_6_8_6_36_#KRewrite| Sort) ))))\n(define-fun theSolution () Solution (Sol (SolVars |VarA| |VarB| |VarC| ) |FreshVarSort_6_8_6_36_#KRewrite| ))\n(define-fun lt ((s1 Solution) (s2 Solution)) Bool (and true (<=SortSyntax (|Sol_VarA| (vars s1)) (|Sol_VarA| (vars s2))) (<=SortSyntax (|Sol_VarB| (vars s1)) (|Sol_VarB| (vars s2))) (<=SortSyntax (|Sol_VarC| (vars s1)) (|Sol_VarC| (vars s2)))  (distinct (vars s1) (vars s2))))\n(assert (and true (distinct (|Sol_FreshVarSort_6_8_6_36_#KRewrite| theSolution) |SortKLabel|) ))\n(define-fun |constraint4_SortExp| ((s Solution)) Bool (and true (<=Sort (|Sol_VarA| (vars s)) |SortExp|) ))\n(define-fun |constraint6_SortExp| ((s Solution)) Bool (and true (<=Sort (|Sol_VarB| (vars s)) |SortExp|) ))\n(define-fun |constraint3_SortExp| ((s Solution)) Bool (and true (<=Sort |SortExp| |SortExp|) (|constraint4_SortExp| s) (|constraint6_SortExp| s) ))\n(define-fun |constraint8_SortExp| ((s Solution)) Bool (and true (<=Sort (|Sol_VarC| (vars s)) |SortExp|) ))\n(define-fun |constraint2_(Sol_FreshVarSort_6_8_6_36_#KRewrite s)| ((s Solution)) Bool (and true (<=Sort |SortExp| (|Sol_FreshVarSort_6_8_6_36_#KRewrite| s)) (|constraint3_SortExp| s) (|constraint8_SortExp| s) ))\n(define-fun |constraint12_SortInt| ((s Solution)) Bool (and true (<=Sort (|Sol_VarA| (vars s)) |SortInt|) ))\n(define-fun |constraint14_SortInt| ((s Solution)) Bool (and true (<=Sort (|Sol_VarB| (vars s)) |SortInt|) ))\n(define-fun |constraint11_SortInt| ((s Solution)) Bool (and true (<=Sort |SortInt| |SortInt|) (|constraint12_SortInt| s) (|constraint14_SortInt| s) ))\n(define-fun |constraint16_SortInt| ((s Solution)) Bool (and true (<=Sort (|Sol_VarC| (vars s)) |SortInt|) ))\n(define-fun |constraint10_(Sol_FreshVarSort_6_8_6_36_#KRewrite s)| ((s Solution)) Bool (and true (<=Sort |SortInt| (|Sol_FreshVarSort_6_8_6_36_#KRewrite| s)) (|constraint11_SortInt| s) (|constraint16_SortInt| s) ))\n(define-fun |constraint1_Sort#RuleBody| ((s Solution)) Bool (and true (= (|Sol_FreshVarSort_6_8_6_36_#KRewrite| s) |SortK|) (|constraint2_(Sol_FreshVarSort_6_8_6_36_#KRewrite s)| s) (|constraint10_(Sol_FreshVarSort_6_8_6_36_#KRewrite s)| s) ))\n(define-fun |constraint0_Sort#RuleContent| ((s Solution)) Bool (and true (|constraint1_Sort#RuleBody| s) ))\n(define-fun |constraint21_SortExp| ((s Solution)) Bool (and true (<=Sort |SortExp| |SortExp|) (|constraint6_SortExp| s) (|constraint8_SortExp| s) ))\n(define-fun |constraint20_(Sol_FreshVarSort_6_8_6_36_#KRewrite s)| ((s Solution)) Bool (and true (<=Sort |SortExp| (|Sol_FreshVarSort_6_8_6_36_#KRewrite| s)) (|constraint4_SortExp| s) (|constraint21_SortExp| s) ))\n(define-fun |constraint19_Sort#RuleBody| ((s Solution)) Bool (and true (= (|Sol_FreshVarSort_6_8_6_36_#KRewrite| s) |SortK|) (|constraint20_(Sol_FreshVarSort_6_8_6_36_#KRewrite s)| s) (|constraint10_(Sol_FreshVarSort_6_8_6_36_#KRewrite s)| s) ))\n(define-fun |constraint18_Sort#RuleContent| ((s Solution)) Bool (and true (|constraint19_Sort#RuleBody| s) ))\n(define-fun amb0 ((s Solution)) Bool (or (|constraint0_Sort#RuleContent| s) (|constraint18_Sort#RuleContent| s) ))\n\n(assert (amb0 theSolution))\n;(assert (not (exists ((s Solution)) (and (lt theSolution s) (amb0 s) (distinct (|Sol_FreshVarSort_6_8_6_36_#KRewrite| s) |SortKLabel|) ))))\n(assert (not (exists ((var SolutionVariables) (s Sort)) (and (lt theSolution (Sol var s)) (amb0 (Sol var s)) (distinct s |SortKLabel|) ))))\n(check-sat)\n(get-model)\n;(assert (or false (distinct |VarA| |SortInt|) (distinct |VarB| |SortInt|) (distinct |VarC| |SortInt|) ))\n;(check-sat)\n"""\n')),(0,o.kt)("h2",{id:"propagate-functions"},"Propagate Functions"),(0,o.kt)("p",null,"We can access the sort ",(0,o.kt)("inlineCode",{parentName:"p"},"Sort")," from the SMTLIB input by declaring it as a ",(0,o.kt)("inlineCode",{parentName:"p"},"DatatypeSort"),".\nThen the two functions we did not define in the SMTLIB input are declared as ",(0,o.kt)("inlineCode",{parentName:"p"},"PropagateFunction"),".\nThis declaration instructs z3 to invoke callbacks whenever a new term headed by the declared\nfunction is introduced to the solver. It could be a term that is part of the input, or it could\nbe a term that is created dynamically using quantifier instantiation."),(0,o.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'\nSort = DatatypeSort("Sort")\nleSort = PropagateFunction("<=Sort", Sort, Sort, BoolSort())\nleSortSyntax = PropagateFunction("<=SortSyntax", Sort, Sort, BoolSort())\nfmls = parse_smt2_string(example, decls={"<=Sort":leSort, "<=SortSyntax":leSortSyntax})\n',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("h2",{id:"axiomatizing-rtcs"},"Axiomatizing RTCs"),(0,o.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"\n[SortInt, SortExp, SortKItem, SortKLabel, SortK] = [Sort.constructor(i) for i in range(Sort.num_constructors())]\n\n\nleSortTable = [(SortKItem, SortK),\n               (SortExp, SortKItem),\n               (SortInt, SortExp)]\n\nleSortSyntaxTable = [(SortKItem, SortK),\n                     (SortExp, SortKItem),\n                     (SortInt, SortExp)]\n\nconstructors = {con() for con in [SortInt, SortExp, SortKItem, SortKLabel, SortK]}\n\n\n# Compute the reflexive transitive closure of a binary relation over constructors.\n\ndef rtc(constructors, bin):\n    step = { k : set([]) for k in constructors }\n    for k, v in bin:\n        step[k()] |= { v() }\n    t = { k : {k} for k in constructors }\n    change = True\n    while change:\n        change = False\n        for k, vs in t.items():\n            sz0 = len(vs)\n            vs |= { w for v in vs for w in step[v] }\n            if len(vs) > sz0:\n                change = True\n    print(t)\n    return t\n",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("h2",{id:"union-find"},"Union Find"),(0,o.kt)("p",null,"We use a simple union find with support for tracking values."),(0,o.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'class Node:\n    def __init__(self, a):\n        self.term = a\n        self.id = a.get_id()\n        self.root = self\n        self.size = 1\n        self.value = None\n\n    def __eq__(self, other):\n        return self.id == other.id\n\n    def __ne__(self, other):\n        return self.id != other.id\n    \n    def to_string(self):\n        return f"{self.term} -> r:{self.root.term}"\n\n    def __str__(self):\n        return self.to_string()\n\nclass UnionFind:\n    def __init__(self, trail):\n        self._nodes = {}\n        self.trail = trail\n\n    def node(self, a):\n        if a in self._nodes:\n            return self._nodes[a]\n        n = Node(a)\n        self._nodes[a] = n\n        def undo():\n            del self._nodes[a]\n        self.trail.append(undo)\n        return n\n\n    def merge(self, a, b):\n        a = self.node(a)\n        b = self.node(b)\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if a.size < b.size:\n            a, b = b, a\n        if a.value is not None and b.value is not None:\n            print("Merging two values", a, a.value, b, b.value)\n            os._exit()\n        value = a.value\n        if b.value is not None:\n            value = b.value        \n        old_root = b.root\n        old_asize = a.size\n        old_bvalue = b.value\n        old_avalue = a.value\n        b.root = a.root\n        b.value = value\n        a.value = value\n        a.size += b.size\n        def undo():\n            b.root = old_root\n            a.size = old_asize\n            b.value = old_bvalue\n            a.value = old_avalue\n        self.trail.append(undo)\n\n    # skip path compression to keep the example basic\n    def find(self, a):\n        assert isinstance(a, Node)\n        root = a.root\n        while root != root.root:\n            root = root.root\n        return root\n\n    def set_value(self, a):\n        n = self.find(self.node(a))\n        if n.value is not None:\n            return\n        def undo():\n            n.value = None\n        n.value = a\n        self.trail.append(undo)\n\n    def get_value(self, a):\n        return self.find(self.node(a)).value        \n\n    def root_term(self, a):\n        return self.find(self.node(a)).term\n\n    def __str__(self):\n        return self.to_string()\n\n    def __repr__(self):\n        return self.to_string()\n\n    def to_string(self):\n        return "\\n".join([n.to_string() for t, n in self._nodes.items()])\n        ',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("h2",{id:"finally-the-propagator"},"Finally, the propagator"),(0,o.kt)("p",null,"It uses a good set of features exposed for user propagators.\nIt illustrates "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Instantiation of basic methods for backtracking and cloning"),(0,o.kt)("li",{parentName:"ul"},"Registering terms to be tracked in callbacks"),(0,o.kt)("li",{parentName:"ul"},"Callbacks for when terms are assigned fixed values"),(0,o.kt)("li",{parentName:"ul"},"Callbacks for new equalities are detected by z3"),(0,o.kt)("li",{parentName:"ul"},"Callbacks when new terms are created using ",(0,o.kt)("inlineCode",{parentName:"li"},"PropagateFunction")),(0,o.kt)("li",{parentName:"ul"},"Callbacks when z3's search is done case splitting")),(0,o.kt)("h3",{id:"tc-as-a-subclass"},"TC as a subclass"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"TC")," solver is instantiated as a subclass of ",(0,o.kt)("inlineCode",{parentName:"p"},"UserPropagateBase"),".\nThe subclass implements three virtual methods ",(0,o.kt)("inlineCode",{parentName:"p"},"push"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"pop"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"fresh"),".\nIt adds other optional callbacks for ",(0,o.kt)("inlineCode",{parentName:"p"},"fixed"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"final"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"eq")," ",(0,o.kt)("inlineCode",{parentName:"p"},"created")," and\ninitializes data-structures for tracking the reflexive transitive closure of\nrelations ",(0,o.kt)("inlineCode",{parentName:"p"},"<=Sort")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"<=SortSyntax"),"."),(0,o.kt)("p",null,"The push/pop callbacks are invoked when z3's CDCL-based solver case splits and backtracks.\nState changes within the scope of a push have to be reverted to an equivalent state.\nIt is not a requirement that the state be exactly the same, but it should preserve\nsatisfiability relative to the previous time it was in the same scope.\nWe restore state using functions that are pushed on a trail whenever some side-effect occurs within a scope."),(0,o.kt)("p",null,"The fresh callback is invoked when z3 creates a nested solver. The main use case for the nested solver is\nz3's model-based quantifier instantiation method, MBQI. MBQI uses the nested solver to check if a quantifier\nis satisfied relative to a candidate model. The nested solver is opaque to the user propagator. Instead\nit sees a new (unique) ",(0,o.kt)("inlineCode",{parentName:"p"},"context")," object. For our use case the nested context shares the same tables for expressions\nso we don't have to maintain separate copies of expressions. If the nested solver is created using threads\n(we are not enabling parallel solving for this example), the expression tables cannot be assumed the same\nand TC would have to set up separate expressions for the new context."),(0,o.kt)("p",null,"The constructor of TC takes an optional solver ",(0,o.kt)("inlineCode",{parentName:"p"},"s")," and an optional context ",(0,o.kt)("inlineCode",{parentName:"p"},"ctx"),".\nInitially it is created using a solver (and not a context).\nNested instances are created using a context (and not a solver)."),(0,o.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"class TC(UserPropagateBase):\n    def __init__(self, s=None, ctx=None):\n        UserPropagateBase.__init__(self, s, ctx)\n        self.trail = []\n        self.lim   = []\n        self.add_fixed(lambda x, v : self._fixed(x, v))\n        self.add_final(lambda : self._final())\n        self.add_eq(lambda x, y : self._eq(x, y))\n        self.add_created(lambda t : self._created(t))\n        self.uf = UnionFind(self.trail)\n        for v in constructors:\n            self.uf.set_value(v)\n        self.first = True\n        self._fixed_le = []\n        self._fixed_le_syntax = []\n        self._fixed_le_table = rtc(constructors, leSortTable)\n        self._fixed_le_syntax_table = rtc(constructors, leSortSyntaxTable)\n\n    def push(self):\n        self.lim += [len(self.trail)]\n\n    def pop(self, n):\n        head = self.lim[len(self.lim) - n]\n        while len(self.trail) > head:\n            self.trail[-1]()\n            self.trail.pop(-1)\n        self.lim = self.lim[0:len(self.lim)-n]\n\n    def fresh(self, new_ctx):\n        return TC(ctx=new_ctx)",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("h3",{id:"handling-assignments-to-fixed-values"},"Handling assignments to fixed values"),(0,o.kt)("p",null,"When ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," is fixed to value ",(0,o.kt)("inlineCode",{parentName:"p"},"v"),", we check if it immediately\ntriggers a conflict. If it doesn't we add it to a trail\nthat is checked on final. It is assumed that during final\n",(0,o.kt)("inlineCode",{parentName:"p"},"check_conflict")," is conclusive (returns True) as all equatlities\nare known between arguments to <=Sort and <=SortSyntax."),(0,o.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'    def _fixed(self, x, v):        \n        print("fixed: ", x, " := ", v)\n        if x.decl().eq(leSort):\n            self._fixed_trail(x, v, self._fixed_le_table, self._fixed_le)\n        elif x.decl().eq(leSortSyntax):\n            self._fixed_trail(x, v, self._fixed_le_syntax_table, self._fixed_le_syntax)\n\n    def _fixed_trail(self, x, v, table, trail):\n        if self.check_conflict(x, v, table):\n            return\n        trail.append((x,v))\n        def undo():\n            trail.pop(-1)\n        self.trail.append(undo)\n',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("h3",{id:"new-terms"},"New Terms"),(0,o.kt)("p",null,"When a new term ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," is created using one of the ",(0,o.kt)("inlineCode",{parentName:"p"},"PropagateFunction")," declarations we receive a callback.\nIt allows register ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," and its two arguments with z3. In return for registering these terms, z3 will\ninvoke ",(0,o.kt)("inlineCode",{parentName:"p"},"fixed")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"eq")," callbacks when z3 infers a fixed value assignment or a new equality between\ntracked terms."),(0,o.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'    def _created(self, t):\n        print("Created", t)\n        self.add(t)\n        x, y = t.arg(0), t.arg(1)\n        self.add(x)\n        self.add(y)\n        if self.first:\n            self.first = False\n            for v in constructors:\n                self.add(v)',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("p",null,"There is a subtle component in this callback: We need to register all constructors with the solver\notherwise, it could be that a constructor does not occur as argument of any\nof the tracked predicates, but gets used by the solver and merged with\none of the arguments during search. If the constructor isn't registered\n",(0,o.kt)("inlineCode",{parentName:"p"},"final()")," cannot resolve the value associated with a ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,o.kt)("h3",{id:"equality-callbacks"},"Equality callbacks"),(0,o.kt)("p",null,"Terms that have been registered using ",(0,o.kt)("inlineCode",{parentName:"p"},"self.add")," are tracked by the solver.\nThe solver issues the equality callback when two registered terms are equated.\nThe number of equality callbacks for ",(0,o.kt)("em",{parentName:"p"},"N")," terms that are equal is ",(0,o.kt)("em",{parentName:"p"},"N-1"),", corresponding\nto a spanning tree. So not all equalities are presented in callbacks and the client\ncan track equivalence classes by using a union-find data-structure as we are doing."),(0,o.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'\n    def _eq(self, x, y):\n        print(x, " = ", y)\n        self.uf.merge(x, y)\n',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("h3",{id:"final-check"},"Final check"),(0,o.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:'    def _final(self):\n        print("Final")\n        self.check_rtc(self._fixed_le, self._fixed_le_table)\n        self.check_rtc(self._fixed_le_syntax, self._fixed_le_syntax_table)\n\n    #\n    # Check if assignment f := v triggers a conflict with respect\n    # to reflexive, transitive closure relation, <=Sort or <=SortSyntax\n    # Look up the values of the two arguments a, b in the\n    # union-find structure.\n    # For\n    #  <=Sort(a,b) := True, check that b is reachable from a\n    #  <=Sort(a,b) := False, check that b is _not_ reachable from a\n    # The process is similar for <=SortSyntax\n    # \n    def check_conflict(self, f, v, rtc, is_final = False):\n        a, b = f.arg(0), f.arg(1)\n        va, vb = self.uf.get_value(a), self.uf.get_value(b)\n        if va is None or vb is None:\n            if is_final:\n                print("Unassigned", a, va, b, vb)\n                os._exit(1)\n            return False\n        if is_true(v):\n            if vb not in rtc[va]:\n                print("Conflict: asserted relation should be included in TC", f, v, a, va, b, vb)\n                self.conflict(deps = [f], eqs = [(a, va), (b, vb)])\n                return True\n            else:\n                return False\n        elif is_false(v):\n            if vb in rtc[va]:\n                print("Conflict: asserted negated relation should not be included in TC", f, v, a, va, b, vb)\n                self.conflict(deps = [f], eqs = [(a, va), (b, vb)])\n                return True\n            else:\n                return False\n        else:\n            print("Unrecognized value", v)\n            assert(False)\n        \n    def check_rtc(self, asserted, rtc):\n        for (f, v) in asserted:            \n            if self.check_conflict(f, v, rtc, is_final = True):\n                return\n',result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}),(0,o.kt)("h2",{id:"using-the-user-propagator"},"Using the User Propagator"),(0,o.kt)(s(),{input:{lang:"z3-python",highlight:"python",statusCodes:{},code:"s = Solver()\nb = TC(s)\n\nfor (a,b) in leSortTable:\n    s.add(leSort(a(),b()))\nfor (a,b) in leSortSyntaxTable:\n    s.add(leSortSyntax(a(), b()))\n    \ns.add(fmls)\nprint(s.check())",result:{},githubRepo:"Z3Prover/z3",editable:!1,readonly:!0,showLineNumbers:!0},mdxType:"CustomCodeBlock"}))}p.isMDXComponent=!0}}]);