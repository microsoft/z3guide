"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4800],{5022:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"optimization/asmallcasestudy","title":"A Small Case Study","description":"In collaboration with Anh-Dung Phan.","source":"@site/docs-smtlib/04 - optimization/06 - asmallcasestudy.md","sourceDirName":"04 - optimization","slug":"/optimization/asmallcasestudy","permalink":"/z3guide/docs/optimization/asmallcasestudy","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/z3guide/tree/main/website/docs-smtlib/04 - optimization/06 - asmallcasestudy.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"A Small Case Study","sidebar_position":6},"sidebar":"smtlibSidebar","previous":{"title":"Combining Objectives","permalink":"/z3guide/docs/optimization/combiningobjectives"},"next":{"title":"Advanced Topics","permalink":"/z3guide/docs/optimization/advancedtopics"}}');var i=t(4848),o=t(8453),a=t(6851);const r={title:"A Small Case Study",sidebar_position:6},l=void 0,d={},c=[{value:"Problem description",id:"problem-description",level:2},{value:"Boolean encoding",id:"boolean-encoding",level:3},{value:"Integer encoding",id:"integer-encoding",level:3}];function x(e){const n={h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"In collaboration with Anh-Dung Phan."}),"\n",(0,i.jsx)(n.h2,{id:"problem-description",children:"Problem description"}),"\n",(0,i.jsx)(n.p,{children:"Use the problem of virtual machine placement as an example. Assume that we have three virtual machines (VMs) which require 100, 50 and 15 GB hard disk respectively. There are three servers with capabilities 100, 75 and 200 GB in that order. Find out a way to place VMs into servers in order to"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Minimize the number of servers used"}),"\n",(0,i.jsx)(n.li,{children:"Minimize the operation cost (the servers have fixed daily costs 10, 5 and 20 USD respectively.)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"boolean-encoding",children:"Boolean encoding"}),"\n",(0,i.jsx)(n.p,{children:"We start with a Boolean encoding. Let xij denote that VM i is put into server j and yj denote that server j is in use."}),"\n",(0,i.jsx)(a.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const x11 Bool)\\n(declare-const x12 Bool)\\n(declare-const x13 Bool)\\n(declare-const x21 Bool)\\n(declare-const x22 Bool)\\n(declare-const x23 Bool)\\n(declare-const x31 Bool)\\n(declare-const x32 Bool)\\n(declare-const x33 Bool)\\n\\n(declare-const y1 Bool)\\n(declare-const y2 Bool)\\n(declare-const y3 Bool)\\n\\n\\n; We express that a virtual machine is on exactly one server by simply converting it to integer constraints.\\n(assert (= (+ x11 x12 x13) 1))\\n(assert (= (+ x21 x22 x23) 1))\\n(assert (= (+ x31 x32 x33) 1))\\n\\n; And an used server is implied by having a VM on it.\\n\\n(assert (and (implies x11 y1) (implies x21 y1) (implies x31 y1)))\\n(assert (and (implies x12 y2) (implies x22 y2) (implies x32 y2)))\\n(assert (and (implies x13 y3) (implies x23 y3) (implies x33 y3)))\\n\\n; Capability constraints are quite natural to add.\\n\\n(assert (<= (+ (* 100 x11) \\n               (* 50 x21) \\n               (* 15 x31)) \\n            (* 100 y1)))\\n(assert (<= (+ (* 100 x12) \\n               (* 50 x22) \\n               (* 15 x32)) \\n            (* 75 y2)))\\n(assert (<= (+ (* 100 x13) \\n               (* 50 x23) \\n               (* 15 x33)) \\n            (* 200 y3)))\\n\\n; Optimization goals are expressed implicitly via assert-soft command.\\n(assert-soft (not y1) :id num_servers)\\n(assert-soft (not y2) :id num_servers)\\n(assert-soft (not y3) :id num_servers)\\n\\n(assert-soft (not y1) :id costs :weight 10)\\n(assert-soft (not y2) :id costs :weight 5)\\n(assert-soft (not y3) :id costs :weight 20)\\n\\n(check-sat)\\n(get-model)\\n(get-objectives)","result":{"output":"sat\\n(\\n  (define-fun x11 () Bool\\n    false)\\n  (define-fun x13 () Bool\\n    true)\\n  (define-fun x21 () Bool\\n    false)\\n  (define-fun x22 () Bool\\n    false)\\n  (define-fun x23 () Bool\\n    true)\\n  (define-fun x31 () Bool\\n    false)\\n  (define-fun x32 () Bool\\n    false)\\n  (define-fun x33 () Bool\\n    true)\\n  (define-fun y1 () Bool\\n    false)\\n  (define-fun y2 () Bool\\n    false)\\n  (define-fun y3 () Bool\\n    true)\\n  (define-fun x12 () Bool\\n    false)\\n)\\n(objectives\\n (num_servers 1)\\n (costs 20)\\n)\\n","error":"","status":"z3-ran","hash":"b894663f400191b1ecbb28bcba900bbf53b0b07d"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.12.1","tool":"z3-solver"}'}),"\n",(0,i.jsx)(n.p,{children:"The assert-soft command represents MaxSMT which tries to maximize the weighted sum of Boolean expressions belonged to the same id. Since we are doing minimization, negation is needed to take advantage of MaxSMT support."}),"\n",(0,i.jsx)(n.h3,{id:"integer-encoding",children:"Integer encoding"}),"\n",(0,i.jsx)(n.p,{children:"In this example, the Boolean encoding is not really natural. Most of the constraints is of arithmetic form, it makes more sense to express them using integer arithmetic. Here is a similar encoding using integer arithmetic."}),"\n",(0,i.jsx)(a.A,{input:'{"lang":"z3","highlight":"clojure","statusCodes":{"success":"z3-ran","timeout":"z3-timed-out","runError":"z3-failed","runtimeError":"z3-runtime-error"},"code":"(declare-const x11 Int)\\n(declare-const x12 Int)\\n(declare-const x13 Int)\\n(declare-const x21 Int)\\n(declare-const x22 Int)\\n(declare-const x23 Int)\\n(declare-const x31 Int)\\n(declare-const x32 Int)\\n(declare-const x33 Int)\\n\\n(declare-const y1 Int)\\n(declare-const y2 Int)\\n(declare-const y3 Int)\\n\\n(assert (and (>= x11 0) (>= x12 0) (>= x13 0) \\n             (>= x21 0) (>= x22 0) (>= x23 0)\\n             (>= x31 0) (>= x32 0) (>= x33 0)))\\n             \\n(assert (and (<= y1 1) (<= y2 1) (<= y3 1)))\\n\\n(assert (= (+ x11 x12 x13) 1))\\n(assert (= (+ x21 x22 x23) 1))\\n(assert (= (+ x31 x32 x33) 1))\\n\\n(assert (and (>= y1 x11) (>= y1 x21) (>= y1 x31)))\\n(assert (and (>= y2 x12) (>= y2 x22) (>= y2 x32)))\\n(assert (and (>= y3 x13) (>= y3 x23) (>= y3 x33)))\\n\\n(assert (<= (+ (* 100 x11) (* 50 x21) (* 15 x31)) (* 100 y1)))\\n(assert (<= (+ (* 100 x12) (* 50 x22) (* 15 x32)) (* 75 y2)))             \\n(assert (<= (+ (* 100 x13) (* 50 x23) (* 15 x33)) (* 200 y3)))\\n\\n(minimize (+ y1 y2 y3))\\n(minimize (+ (* 10 y1) (* 5 y2) (* 20 y3)))\\n\\n;(set-option :opt.priority pareto)\\n(check-sat)\\n(get-model)\\n(get-objectives)","result":{"output":"sat\\n(\\n  (define-fun x33 () Int\\n    1)\\n  (define-fun x13 () Int\\n    1)\\n  (define-fun y2 () Int\\n    0)\\n  (define-fun y3 () Int\\n    1)\\n  (define-fun y1 () Int\\n    0)\\n  (define-fun x32 () Int\\n    0)\\n  (define-fun x22 () Int\\n    0)\\n  (define-fun x12 () Int\\n    0)\\n  (define-fun x23 () Int\\n    1)\\n  (define-fun x21 () Int\\n    0)\\n  (define-fun x11 () Int\\n    0)\\n  (define-fun x31 () Int\\n    0)\\n)\\n(objectives\\n ((+ y1 y2 y3) 1)\\n ((+ (* 10 y1) (* 5 y2) (* 20 y3)) 20)\\n)\\n","error":"","status":"z3-ran","hash":"6740a13d9dad9a763018bf085a028e1577115998"},"githubRepo":"Z3Prover/z3","editable":false,"readonly":false,"showLineNumbers":true,"langVersion":"4.12.1","tool":"z3-solver"}'}),"\n",(0,i.jsx)(n.p,{children:"The capability constraints and goals are easier to express than those of Boolean encoding. However, we need to add extra constraints to ensure that only 0-1 integers are allowed in the model. It is also interesting to see different results by choosing various ways of combining objectives. You can uncomment the set-option command and take a look at results."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(x,{...e})}):x(e)}}}]);