{"input":"(set-option :smt.mbqi true)\n(set-option :model.compact true)\n\n;; A, B, C and D are sets of Int\n(declare-fun A (Int) Bool)\n(declare-fun B (Int) Bool)\n(declare-fun C (Int) Bool)\n(declare-fun D (Int) Bool)\n\n;; A union B is a subset of C\n(assert (forall ((x Int)) (= (or (A x) (B x)) (C x))))\n\n;; B minus A is not empty\n;; That is, there exists an integer e that is B but not in A\n(declare-const e Int)\n(assert (and (B e) (not (A e))))\n\n;; D is equal to C\n(assert (forall ((x Int)) (iff (D x) (C x))))\n\n;; 0, 1 and 2 are in B\n(assert (B 0))\n(assert (B 1))\n(assert (B 2))\n\n(check-sat)\n(get-model)\n(echo Is e an element of D)\n(eval (D e))\n\n(echo Now proving that A is a strict subset of D)\n;; This is true if the negation is unsatisfiable\n(push)\n(assert (not (and \n              ;; A is a subset of D\n              (forall ((x Int)) (= (A x) (D x)))\n              ;; but, D has an element that is not in A.\n              (exists ((x Int)) (and (D x) (not (A x)))))))\n(check-sat)\n(pop)"}
