{"input":"(set-option smt.mbqi true)\n(set-option model.compact true)\n\n;; T is an uninterpreted sort\n(declare-sort T) \n\n(declare-fun subtype (T T) Bool)\n\n;; subtype is reflexive\n(assert (forall ((x T)) (subtype x x)))\n\n;; subtype is antisymmetric\n(assert (forall ((x T) (y T)) (= (and (subtype x y)\n                                       (subtype y x))\n                                       (= x y))))\n;; subtype is transitive\n(assert (forall ((x T) (y T) (z T)) (= (and (subtype x y)\n                                             (subtype y z))\n                                             (subtype x z))))\n;; subtype has the tree-property\n(assert (forall ((x T) (y T) (z T)) (= (and (subtype x z)\n                                             (subtype y z))\n                                        (or (subtype x y)\n                                            (subtype y x)))))\n\n;; now we define a simple example using the axiomatization above.\n(declare-const obj-type T)\n(declare-const int-type T)\n(declare-const real-type T)\n(declare-const complex-type T)\n(declare-const string-type T)\n\n;; we have an additional axiom every type is a subtype of obj-type\n(assert (forall ((x T)) (subtype x obj-type)))\n\n(assert (subtype int-type real-type))\n(assert (subtype real-type complex-type))\n(assert (not (subtype string-type real-type)))\n(declare-const root-type T)\n(assert (subtype obj-type root-type))\n(check-sat)\n(get-model)\n\n(echo Is int-type a subtype of complex-type)\n(eval (subtype int-type complex-type))\n(echo Is int-type = obj-type)\n(eval (= int-type obj-type))\n(echo Is int-type a subtype of root-type)\n(eval (subtype int-type root-type))\n(echo Is root-type = obj-type)\n(eval (= root-type obj-type))"}
