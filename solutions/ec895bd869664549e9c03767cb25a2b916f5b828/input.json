{"input":"(set-option smt.mbqi true)\n;; Ptr is the pointer sort.\n(declare-sort Ptr)\n;; (next p) represents p.next\n;; The pointer reached by following the field next of p.\n(declare-fun next  (Ptr) Ptr)\n(declare-fun prev  (Ptr) Ptr)\n(declare-fun state (Ptr) Int)\n(declare-fun prio  (Ptr) Int)\n(declare-const null Ptr)\n(declare-const RUN  Int)\n(declare-const SLP  Int)\n(assert (distinct RUN SLP))\n\n;; Asserting data-structure invariants in the current state.\n\n;; p != null && p.next != null = p.next.prev = p\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (next p) null)))\n                    (= (prev (next p)) p))))\n\n;; p != null && p.prev != null = p.prev.next = p\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (prev p) null)))\n                    (= (next (prev p)) p))))\n\n;;  p != null && p.prev != null = p.state = p.next.state\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (next p) null)))\n                    (= (state p) (state (next p))))))\n\n;;  p != null && p.prev != null && p.state = RUN = p.prio = p.next.prio\n(assert (forall ((p Ptr))\n                (= (and (not (= p null))\n                         (not (= (next p) null))\n                         (= (state p) RUN))\n                    (= (prio p) (prio (next p))))))\n\n;; Verifying Verification Conditions (VCs) for remove procdure\n(declare-const x Ptr)\n;; new-state, new-next, new-prev and new-prio represent the state \n;; of the system after executing the remove procedure.\n(declare-fun new-state (Ptr) Int)\n(declare-fun new-next  (Ptr) Ptr)\n(declare-fun new-prev  (Ptr) Ptr)\n(declare-fun new-prio  (Ptr) Int)\n;; pre-conditions\n(assert (not (= x null)))\n(assert (not (= (prev x) null)))\n(assert (= (state x) RUN))\n;; updates\n;; --- new-prev = prev\n(assert (forall ((p Ptr)) (= (new-prev p) (prev p))))\n;; --- new-prio = prio\n(assert (forall ((p Ptr)) (= (new-prio p) (prio p))))\n;; --- new-state = state[x - SLP]\n(assert (= (new-state x) SLP))\n(assert (forall ((p Ptr)) (or (= p x) (= (new-state p) (state p)))))\n;; ----\n;; --- new-next  = next[(prev x) - (next x); x - null]\n(assert (= (new-next x) null))\n(assert (= (new-next (prev x)) (next x)))\n(assert (forall ((p Ptr)) (or (= p x) (= p (prev x)) (= (new-next p) (next p)))))\n;; ---\n\n;; Proving the data-structure invariants in the new state.\n\n(push)\n(assert (not (forall ((p Ptr))\n                     (= (and (not (= p null))\n                              (not (= (new-next p) null)))\n                         (= (new-prev (new-next p)) p)))))\n(check-sat)\n(get-model)\n(pop)\n(echo Why it is not valid)\n(echo Trying again using a fresh constant bad-ptr as an witness for the failure...)\n(push)\n(declare-const bad-ptr Ptr)\n(assert (not (= (and (not (= bad-ptr null))\n                      (not (= (new-next bad-ptr) null)))\n                 (= (new-prev (new-next bad-ptr)) bad-ptr))))\n(check-sat)\n(get-model)\n(echo null is)\n(eval null)\n(echo bad-ptr is)\n(eval bad-ptr)\n(echo In the new state, bad-ptr.next is)\n(eval (new-next bad-ptr))\n(echo In the new state, bad-ptr.next.prev is)\n(eval (new-prev (new-next bad-ptr)))\n(pop)"}
