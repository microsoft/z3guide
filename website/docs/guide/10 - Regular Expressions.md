---
title: Regular Expressions
sidebar_position: 10
---

The sort constructor `RegEx` takes as argument a sequence type.
The set of regular expressions over strings is thus `(RegEx String)`; 
it is synomumous with the sort `RegLan` defined in the [SMTLIB2 format](http://smtlib.cs.uiowa.edu/theories-UnicodeStrings.shtml).

# Summary of Operations

<table>
  <tr>
    <td>Operation</td>
    <td>Brief description</td>
  </tr>
  <tr> 
    <td><tt>(str.to.re s)</tt></td>
    <td>Convert string to regular expression accepting <tt>s</tt>.</td>
  </tr>
  <tr> 
    <td><tt>(str.in.re s r)</tt></td>
    <td>Determine if <tt>s</tt> is in the language generated by <tt>r</tt>.</td>
  </tr>
  <tr> 
    <td><tt>re.allchar</tt></td>
    <td>The regular expression accepting every string.</td>
  </tr>
  <tr> 
    <td><tt>re.nostr</tt></td>
    <td>The regular expression rejecting every string.</td>
  </tr>
  <tr> 
    <td><tt>(re.range ch1 ch2)</tt></td>
    <td>The range of characters (represented as strings) between <tt>ch1</tt> and <tt>ch2</tt>.</td>
  </tr>
  <tr> 
    <td><tt>(re.++ r1 r2 r3)</tt></td>
    <td>Concatenation of regular expressions.</td>
  </tr>
  <tr> 
    <td><tt>(re.* r)</tt></td>
    <td>Kleene star.</td>
  </tr>
  <tr> 
    <td><tt>(re.+ r)</tt></td>
    <td>Kleene plus.</td>
  </tr>
  <tr> 
    <td><tt>(re.opt r)</tt></td>
    <td>Zero or one use of <tt>r</tt>.</td>
  </tr>
  <tr> 
    <td><tt>((_ re.loop lo hi) r)</tt></td>
    <td>from <tt>lo</tt> to <tt>hi</tt> number of repetitions of <tt>r</tt>.</td>
  </tr>  
  <tr> 
    <td><tt>(re.union r1 r2)</tt></td>
    <td>The union of regular languages.</td>
  </tr>
  <tr> 
    <td><tt>(re.inter r1 r2)</tt></td>
    <td>The intersection of regular languages. </td>
  </tr>

  <tr> 
    <td><tt>(seq.to.re s)</tt></td>
    <td>Convert sequence to regular expression accepting <tt>s</tt>.</td>
  </tr>
  <tr> 
    <td><tt>(seq.in.re s r)</tt></td>
    <td>Determine if sequence <tt>s</tt> is in the language generated by <tt>r</tt>.</td>
  </tr>
  <tr> 
    <td><tt>(as re.all R)</tt></td>
    <td>The regular expression of sort <tt>R</tt> accepting every sequence.</td>
  </tr>
  <tr> 
    <td><tt>(as re.empty R)</tt></td>
    <td>The regular expression of sort <tt>R</tt> rejecting every sequence.</td>
  </tr>


</table>

The `re.range` operator expects two strings each encoding a single character.
For example `(re.range "a" "\u{ff}")` is a valid range of characters, 
while `(re.range "aa" "")` is the empty language. 

```z3
(simplify (re.range "a" "\u{ff}"))
(simplify (re.range "aa" ""))
```

For  compatibility with the SMTLIB2 format 
Z3 also accepts expressions of the form `(re.loop r lo hi)`.
Z3 understands only the meaning of these terms when `lo, hi` are 
integer numerals.

# What (not) to expect of regular expressions
The default solver for regular expressions unfolds membership relations of regular expressions lazily.
It uses [symbolic derivatives](https://dl.acm.org/doi/abs/10.1145/3453483.3454066) .
This approach works for many membership and non-membership constraints, but is not a complete 
procedure when membership constraints are combined with constraints over strings.
Note that the syntax allows forming _symbolic_ regular expressions that contain uninterpreted non-terminals.
It also does not handle regular expressions symbolic sequences (it allows
to express non-regular languages).
Thus, the string <tt>s</tt> in <tt>(str.to.re s)</tt> should be 
a string literal. You can write formulas with equalities over 
regular expressions. Z3 is a decision procedure for equalities and disequalities between non-symbolic regular expressions.

# Examples

The maximal length is 6 for a string of length 2 repeated at most 3 times.

```z3
(declare-const a String)
(push)
(set-info :status sat)
(assert (str.in.re a ((_ re.loop 1 3) (str.to.re "ab"))))
(assert (= (str.len a) 6))
(check-sat)
(get-model)
(pop)

(push)
(set-info :status unsat)
(assert (str.in.re a ((_ re.loop 1 3) (str.to.re "ab"))))
(assert (> (str.len a) 6))
(check-sat)
(pop)
```
 
