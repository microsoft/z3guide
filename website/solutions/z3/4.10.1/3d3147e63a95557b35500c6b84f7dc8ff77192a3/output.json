{"output":"sat\n(\n  ;; universe for Ptr:\n  ;;   Ptr!val!2 Ptr!val!1 Ptr!val!0 \n  ;; -----------\n  ;; definitions for universe elements:\n  (declare-fun Ptr!val!2 () Ptr)\n  (declare-fun Ptr!val!1 () Ptr)\n  (declare-fun Ptr!val!0 () Ptr)\n  ;; cardinality constraint:\n  (forall ((x Ptr)) (or (= x Ptr!val!2) (= x Ptr!val!1) (= x Ptr!val!0)))\n  ;; -----------\n  (define-fun SLP () Int\n    3)\n  (define-fun null () Ptr\n    Ptr!val!1)\n  (define-fun x () Ptr\n    Ptr!val!0)\n  (define-fun RUN () Int\n    2)\n  (define-fun prev ((x!0 Ptr)) Ptr\n    (ite (= x!0 Ptr!val!0) Ptr!val!2\n    (ite (= x!0 Ptr!val!2) Ptr!val!0\n      Ptr!val!1)))\n  (define-fun next ((x!0 Ptr)) Ptr\n    (ite (= x!0 Ptr!val!0) Ptr!val!2\n    (ite (= x!0 Ptr!val!2) Ptr!val!0\n      Ptr!val!1)))\n  (define-fun prio ((x!0 Ptr)) Int\n    0)\n  (define-fun new-prio ((x!0 Ptr)) Int\n    (ite (= x!0 Ptr!val!0) 0\n    (ite (= x!0 Ptr!val!2) 0\n      (prio x!0))))\n  (define-fun new-prev ((x!0 Ptr)) Ptr\n    (ite (= x!0 Ptr!val!0) Ptr!val!2\n    (ite (= x!0 Ptr!val!2) Ptr!val!0\n      (prev x!0))))\n  (define-fun state ((x!0 Ptr)) Int\n    2)\n  (define-fun new-state ((x!0 Ptr)) Int\n    (ite (= x!0 Ptr!val!0) 3\n    (ite (= x!0 Ptr!val!2) 2\n      (state x!0))))\n  (define-fun new-next ((x!0 Ptr)) Ptr\n    (ite (= x!0 Ptr!val!0) Ptr!val!1\n    (ite (= x!0 Ptr!val!2) Ptr!val!2\n      (next x!0))))\n)\nWhy it is not valid?\nTrying again using a fresh constant bad-ptr as an witness for the failure...\nsat\n(\n  ;; universe for Ptr:\n  ;;   Ptr!val!3 Ptr!val!5 Ptr!val!2 Ptr!val!1 Ptr!val!4 Ptr!val!0 \n  ;; -----------\n  ;; definitions for universe elements:\n  (declare-fun Ptr!val!3 () Ptr)\n  (declare-fun Ptr!val!5 () Ptr)\n  (declare-fun Ptr!val!2 () Ptr)\n  (declare-fun Ptr!val!1 () Ptr)\n  (declare-fun Ptr!val!4 () Ptr)\n  (declare-fun Ptr!val!0 () Ptr)\n  ;; cardinality constraint:\n  (forall ((x Ptr))\n          (or (= x Ptr!val!3)\n              (= x Ptr!val!5)\n              (= x Ptr!val!2)\n              (= x Ptr!val!1)\n              (= x Ptr!val!4)\n              (= x Ptr!val!0)))\n  ;; -----------\n  (define-fun bad-ptr () Ptr\n    Ptr!val!2)\n  (define-fun SLP () Int\n    3)\n  (define-fun x () Ptr\n    Ptr!val!0)\n  (define-fun RUN () Int\n    2)\n  (define-fun null () Ptr\n    Ptr!val!1)\n  (define-fun prev ((x!0 Ptr)) Ptr\n    (ite (= x!0 Ptr!val!0) Ptr!val!2\n    (ite (= x!0 Ptr!val!3) Ptr!val!0\n    (ite (= x!0 Ptr!val!4) Ptr!val!3\n    (ite (= x!0 Ptr!val!5) Ptr!val!4\n      Ptr!val!1)))))\n  (define-fun next ((x!0 Ptr)) Ptr\n    (ite (= x!0 Ptr!val!0) Ptr!val!3\n    (ite (= x!0 Ptr!val!2) Ptr!val!0\n    (ite (= x!0 Ptr!val!3) Ptr!val!4\n    (ite (= x!0 Ptr!val!4) Ptr!val!5\n      Ptr!val!1)))))\n  (define-fun prio ((x!0 Ptr)) Int\n    0)\n  (define-fun new-prio ((x!0 Ptr)) Int\n    (ite (= x!0 Ptr!val!2) 0\n    (ite (= x!0 Ptr!val!0) 0\n    (ite (= x!0 Ptr!val!3) 0\n    (ite (= x!0 Ptr!val!4) 0\n    (ite (= x!0 Ptr!val!5) 0\n      (prio x!0)))))))\n  (define-fun new-prev ((x!0 Ptr)) Ptr\n    (ite (= x!0 Ptr!val!0) Ptr!val!2\n    (ite (= x!0 Ptr!val!3) Ptr!val!0\n    (ite (= x!0 Ptr!val!4) Ptr!val!3\n    (ite (= x!0 Ptr!val!5) Ptr!val!4\n      (prev x!0))))))\n  (define-fun state ((x!0 Ptr)) Int\n    2)\n  (define-fun new-state ((x!0 Ptr)) Int\n    (ite (= x!0 Ptr!val!0) 3\n    (ite (= x!0 Ptr!val!2) 2\n    (ite (= x!0 Ptr!val!3) 2\n    (ite (= x!0 Ptr!val!4) 2\n    (ite (= x!0 Ptr!val!5) 2\n      (state x!0)))))))\n  (define-fun new-next ((x!0 Ptr)) Ptr\n    (ite (= x!0 Ptr!val!0) Ptr!val!1\n    (ite (= x!0 Ptr!val!2) Ptr!val!3\n    (ite (= x!0 Ptr!val!3) Ptr!val!4\n    (ite (= x!0 Ptr!val!4) Ptr!val!5\n    (ite (= x!0 Ptr!val!5) Ptr!val!1\n      (next x!0)))))))\n)\nnull is\nPtr!val!1\nbad-ptr is\nPtr!val!2\nIn the new state, bad-ptr.next is\nPtr!val!3\nIn the new state, bad-ptr.next.prev is\nPtr!val!0\n","error":"","status":"z3-ran","hash":"3d3147e63a95557b35500c6b84f7dc8ff77192a3"}
