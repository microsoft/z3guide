{"input":"(declare-const x11 Bool)\n(declare-const x12 Bool)\n(declare-const x13 Bool)\n(declare-const x21 Bool)\n(declare-const x22 Bool)\n(declare-const x23 Bool)\n(declare-const x31 Bool)\n(declare-const x32 Bool)\n(declare-const x33 Bool)\n\n(declare-const y1 Bool)\n(declare-const y2 Bool)\n(declare-const y3 Bool)\n\n\n; We express that a virtual machine is on exactly one server by simply converting it to integer constraints.\n(assert (= (+ x11 x12 x13) 1))\n(assert (= (+ x21 x22 x23) 1))\n(assert (= (+ x31 x32 x33) 1))\n\n; And an used server is implied by having a VM on it.\n\n(assert (and (implies y1 x11) (implies y1 x21) (implies y1 x31)))\n(assert (and (implies y2 x12) (implies y2 x22) (implies y2 x32)))\n(assert (and (implies y3 x13) (implies y3 x23) (implies y3 x33)))\n\n; Capability constraints are quite natural to add.\n\n(assert (<= (+ (* 100 x11) \n               (* 50 x21) \n               (* 15 x31)) \n            (* 100 y1)))\n(assert (<= (+ (* 100 x12) \n               (* 50 x22) \n               (* 15 x32)) \n            (* 75 y2)))\n(assert (<= (+ (* 100 x13) \n               (* 50 x23) \n               (* 15 x33)) \n            (* 200 y3)))\n\n; Optimization goals are expressed implicitly via assert-soft command.\n(assert-soft (not y1) :id num_servers)\n(assert-soft (not y2) :id num_servers)\n(assert-soft (not y3) :id num_servers)\n\n(assert-soft (not y1) :id costs :weight 10)\n(assert-soft (not y2) :id costs :weight 5)\n(assert-soft (not y3) :id costs :weight 20)\n\n(check-sat)\n(get-model)\n(get-objectives)"}
