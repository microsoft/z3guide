{"input":"(declare-datatypes () ((Type \n  int \n  string \n  (arrow (dom Type) (rng Type)))))\n(declare-sort Var)\n(declare-datatypes () ((M \n  (lam (bound Var) (body M)) \n  (var (v Var)) \n  (app (fn M) (arg M)))))\n(declare-fun type (M) Type)\n(define-fun dom ((M M)) Type (dom (type M)))\n(define-fun rng ((M M)) Type (rng (type M)))\n(define-fun type ((x Var)) Type (type (var x)))\n(declare-const x Var)\n(declare-const y Var)\n(define-fun app-constraint ((M1 M) (M2 M)) Bool\n  (and (= (dom M1) (type M2))\n       (is-arrow (type M1))\n       (= (type (app M1 M2)) (rng M1)))\n)\n(define-fun lam-constraint ((x Var) (M M)) Bool\n  (= (type (lam x M)) (arrow (type x) (type M)))\n)\n\n(define-fun-rec type-constraints ((M M)) Bool\n    (match M\n     (case (var x) true)\n     (case (app M1 M2)\n         (if (app-constraint M1 M2)\n             (and (type-constraints M1) (type-constraints M2)) \n             false))\n     (case (lam x M1)\n         (if (lam-constraint x M1)\n             (type-constraints M1) \n             false))\n    )\n)\n\n; the identity function can be typed.\n(push)\n(assert (type-constraints (lam x (var x))))\n(check-sat)\n(pop)\n\n; there is no simple type for x such that (x x) is well typed.\n; the type constraints are unsat due to the semantics of algebraic\n; data-types: it is not possible to create an instance of an\n; algebraic data-type that is a sub-term of itself.\n(push)\n(assert (type-constraints (lam x (app (var x) (var x)))))\n(check-sat)\n(pop)\n\n; Applying a function that takes an integer to a string is not well-typed\n(push)\n(declare-const plus M)\n(assert (= (type plus) (arrow int (arrow int int))))\n(declare-fun ofint (Int) M)\n(assert (= (type (ofint 3)) int))\n(declare-fun ofstring (String) M)\n(assert (= (type (ofstring \"a\")) string))\n(assert (type-constraints (app (lam x (app (app plus (var x)) (ofint 3))) (ofstring \"a\"))))\n(check-sat)\n(pop)"}
